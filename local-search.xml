<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>sql连接和groupBy</title>
    <link href="/2024/05/07/mysql1/"/>
    <url>/2024/05/07/mysql1/</url>
    
    <content type="html"><![CDATA[<p>分清楚内连接、外连接（左（外）连接、右（外）连接）</p><p>前提</p><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `a_table` (<br>  `a_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `a_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `a_part` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `b_table` (<br>  `b_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `b_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `b_part` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><p>表测试的两个数据</p><p>a_table</p><table><thead><tr><th align="center">a_id</th><th align="center">a_name</th><th align="center">a_part</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">老潘</td><td align="center">总裁部</td></tr><tr><td align="center">2</td><td align="center">老王</td><td align="center">秘书部</td></tr><tr><td align="center">3</td><td align="center">老张</td><td align="center">设计部</td></tr><tr><td align="center">4</td><td align="center">老李</td><td align="center">运营部</td></tr></tbody></table><p>b_table</p><table><thead><tr><th align="center">b_id</th><th align="center">b_name</th><th align="center">b_part</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">老王</td><td align="center">秘书部</td></tr><tr><td align="center">3</td><td align="center">老张</td><td align="center">设计部</td></tr><tr><td align="center">5</td><td align="center">老刘</td><td align="center">人事部</td></tr><tr><td align="center">6</td><td align="center">老黄</td><td align="center">生产部</td></tr></tbody></table><h2 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h2><p>关键字：inner join on或者inner join where</p><p>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> a_table <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> b_table <br><span class="hljs-keyword">WHERE</span> a_table.a_id <span class="hljs-operator">=</span> b_table.b_id;<br></code></pre></td></tr></table></figure><p>执行的结果</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240506231804.png"></p><p>说明组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集部分</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240506233554.png"></p><h2 id="2、左连接（左外连接）"><a href="#2、左连接（左外连接）" class="headerlink" title="2、左连接（左外连接）"></a>2、左连接（左外连接）</h2><p>关键字：left join on &#x2F;  left outer join on</p><p>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> a_table <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> b_table<br><span class="hljs-keyword">on</span> a_table.a_id <span class="hljs-operator">=</span> b_table.b_id;<br></code></pre></td></tr></table></figure><p>执行的结果</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240506233931.png"></p><p>left join on是left outer join on的一种缩写，它的全称是左外连接，是外连接的一种</p><p>左（外）连接，左表（a_table)的记录将会全部表示出来，而右表（b_table）只会显示符合搜索条件的记录。右表记录不足的地方均为null。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240506234305.png"></p><h2 id="3、右连接（右外连接）"><a href="#3、右连接（右外连接）" class="headerlink" title="3、右连接（右外连接）"></a>3、右连接（右外连接）</h2><p>关键字：right join on &#x2F; right outer join on</p><p>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> a_table <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> b_table<br><span class="hljs-keyword">on</span> a_table.a_id <span class="hljs-operator">=</span> b_table.b_id;<br></code></pre></td></tr></table></figure><p>执行的结果：</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240506234535.png"></p><p>right join on是right outer join on的一种缩写，它的全称是左外连接，是外连接的一种</p><p>右（外）连接，右表（b_table)的记录将会全部表示出来，而左表（a_table）只会显示符合搜索条件的记录。左表记录不足的地方均为null。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240506234731.png"></p><p><a href="https://leetcode.cn/problems/combine-two-tables/description/">175. 组合两个表 - 力扣（LeetCode）</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> firstName, lastName, city, state<br><span class="hljs-keyword">From</span> Person <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">join</span> Address<br><span class="hljs-keyword">on</span> Person.PersonId <span class="hljs-operator">=</span> Address.PersonId;<br></code></pre></td></tr></table></figure><h2 id="1、groupBy"><a href="#1、groupBy" class="headerlink" title="1、groupBy"></a>1、groupBy</h2><p>前提：建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `staff` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键id&#x27;</span>,<br>  `id_card` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;身份证号码&#x27;</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  `city` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;城市&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">15</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;员工表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240507085302.png"></p><p>1、统计每一个城市员工的数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> city, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">FROM</span> staff<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city;<br></code></pre></td></tr></table></figure><p><code>as  num</code>将新的城市员工的数量这一列的索引置为num</p><p>分析一下底层的执行流程</p><h2 id="2、group-By原理分析"><a href="#2、group-By原理分析" class="headerlink" title="2、group By原理分析"></a>2、group By原理分析</h2><h3 id="2-1、explain分析"><a href="#2-1、explain分析" class="headerlink" title="2.1、explain分析"></a>2.1、explain分析</h3><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240507090045.png"></p><ul><li>extra这个字段的<code>Using temporary</code>表示在执行分组的时候使用了临时表。</li></ul><blockquote><p>创建内存临时表，表中具有两个字段，city和num。</p><p>全表扫描stuff的记录，依次取出city &#x3D; ‘X’的记录。</p><ul><li>判断临时表中具有city &#x3D; ‘X’的行，没有就插入一个记录(x, 1)；</li><li>如果临时表中具有city &#x3D; ‘X’的 行的行，就是将x这一行的num + 1；</li></ul></blockquote><h2 id="3、where-和-having的区别"><a href="#3、where-和-having的区别" class="headerlink" title="3、where 和 having的区别"></a>3、where 和 having的区别</h2><ul><li>group by + where 的执行流程</li><li>group by + having的执行流程</li><li>同时有where、group by、having的执行顺序</li></ul><h3 id="3-1、group-by-where的执行流程"><a href="#3-1、group-by-where的执行流程" class="headerlink" title="3.1、group by + where的执行流程"></a>3.1、group by + where的执行流程</h3><p>2、筛选出年龄大于19岁的员工，并按城市分组，统计每个城市的员工数量，最后按员工数量升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> city, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">FROM</span> staff<br><span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">19</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> num <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>创建内存临时表，表里有两个字段city和num；</li><li>扫描索引树idx_age，找到大于年龄大于30的主键ID</li><li>通过主键ID，回表找到city &#x3D; ‘X’</li></ol><ul><li>判断<strong>临时表</strong>中是否有为 city&#x3D;’X’的行，没有就插入一个记录 (X,1);</li><li>如果临时表中有city&#x3D;’X’的行的行，就将x 这一行的num值加 1；</li></ul><ol><li>继续重复2,3步骤，找到所有满足条件的数据，</li><li>最后根据字段city做<strong>排序</strong>，得到结果集返回给客户端。</li></ol><h3 id="3-2、group-by-having的执行流程"><a href="#3-2、group-by-having的执行流程" class="headerlink" title="3.2、group by + having的执行流程"></a>3.2、group by + having的执行流程</h3><p>3、查询每个城市的员工数量，获取到员工数量不低于3的城市，having可以很好解决你的问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> city, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">FROM</span> staff<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city<br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3、同时有where、group-by、having的执行顺序"><a href="#3-3、同时有where、group-by、having的执行顺序" class="headerlink" title="3.3、同时有where、group by、having的执行顺序"></a>3.3、同时有where、group by、having的执行顺序</h3><p>4、筛选出年龄大于19岁的员工，并按城市分组，统计每个城市的员工数量，选出员工数量大于3的城市</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> city, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">FROM</span> staff<br><span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">19</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city<br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="3-4、Having和where的区别"><a href="#3-4、Having和where的区别" class="headerlink" title="3.4、Having和where的区别"></a>3.4、Having和where的区别</h3><ul><li>having子句用于<strong>分组后的筛选</strong>，where子句用于行条件筛选</li><li>having一般都是配合group by和聚合函数一起出现的如(count(),sum(),avg(),max(),min())</li><li>where条件子句中不能使用聚合函数，而having子句就可以</li><li>having只能放在group之后，where执行在group by之前</li></ul><p><a href="https://leetcode.cn/problems/actors-and-directors-who-cooperated-at-least-three-times/submissions/530314283/">1050. 合作过至少三次的演员和导演 - 力扣（LeetCode）</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> actor_id, director_id<br><span class="hljs-keyword">from</span> ActorDirector<br><span class="hljs-keyword">Group</span> <span class="hljs-keyword">by</span> actor_id, director_id<br><span class="hljs-keyword">Having</span> <span class="hljs-built_in">count</span>(<span class="hljs-type">timestamp</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这个题目中，如果用<code>select actor_id, director_id, count(timestamp) as num</code>会更好理解一些</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql语句练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC第396场周赛</title>
    <link href="/2024/05/05/week_match003/"/>
    <url>/2024/05/05/week_match003/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/valid-word/description/">100284. 有效单词 - 力扣（LeetCode）</a></p><p>这一道题完全拿下，到最后发现其实不用对于数字进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (word.length() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs_Letter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span> (Character.isLetterOrDigit(c))&#123;<br>                <span class="hljs-keyword">if</span> (Character.isLetter(c)) bs_Letter.append(Character.toLowerCase(c));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : bs_Letter.toString().toCharArray())&#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span>|| c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span>|| c == <span class="hljs-string">&#x27;o&#x27;</span>|| c == <span class="hljs-string">&#x27;u&#x27;</span>)&#123;<br>                a++;<br>            &#125;<span class="hljs-keyword">else</span> b++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">1</span> || b &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-word-k-periodic/description/">100275. K 周期字符串需要的最少操作次数 - 力扣（LeetCode）</a></p><p>这一道题也是完全拿下的，发现规律之后挺容易的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperationsToMakeKPeriodic</span><span class="hljs-params">(String word, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += k) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> word.substring(i,i + k);<br>            map.put(v, map.getOrDefault(v, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer c : map.values())&#123;<br>           a =  Math.max(a, c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n/k - a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-length-of-anagram-concatenation/description/">3138. 同位字符串连接的最小长度 - 力扣（LeetCode）</a></p><p>这道题目没有拿下，想到了求出每一个单词的数量，但是没有想得到求公约数（求公约数这一招确实很妙）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a % b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> b;<br>        <span class="hljs-keyword">return</span> gcd(b, a % b);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAnagramLength</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), res = n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[i] != <span class="hljs-number">0</span>)&#123;<br>                res = gcd(res, cnt[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n/res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四道就算了呜呜呜~~~</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashTableⅠ</title>
    <link href="/2024/04/26/HashTable1/"/>
    <url>/2024/04/26/HashTable1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate/description/">217. 存在重复元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : nums) map.put(e, map.getOrDefault(e, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> entry.getValue();<br><span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Set&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : nums1) set1.add(e);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : nums2) set2.add(e);<br>List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Integer e : set2)&#123;<br><span class="hljs-keyword">if</span> (set1.contains(e))&#123;<br>ans.add(e);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>ret[i] = ans.get(i);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">128. 最长连续序列 - 力扣（LeetCode）</a></p><p>这个题如果不用暴力的话我踏马还真想不起来用啥~~~</p><p>我做了一遍之后开始不明白为啥就要非得判断<code>if (!set.contains(e - 1))</code>我不能从大向着小判断吗？</p><ul><li>其实这两个都可以，但是它的目的就是为了寻找连续的那一个极值点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : nums) set.add(e);<br><span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : nums)&#123;<br><span class="hljs-keyword">if</span> (!set.contains(e - <span class="hljs-number">1</span>))&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">cur_Num</span> <span class="hljs-operator">=</span> e;<br><span class="hljs-type">int</span> <span class="hljs-variable">cur_long</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (set.contains(cur_Num + <span class="hljs-number">1</span>))&#123;<br>cur_Num++;<br>cur_long++;<br>&#125;<br>ret = Math.max(ret, cur_long);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/word-pattern/">290. 单词规律 - 力扣（LeetCode）</a></p><p>这个简单题挺难的，也挺怪的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordPattern</span><span class="hljs-params">(String pattern, String s)</span> &#123;<br>        Map&lt;Character, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        String[] v = s.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> pattern.length();<br>        <span class="hljs-keyword">if</span>(len != v.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> pattern.charAt(i);<br>            <span class="hljs-keyword">if</span>(!map.containsKey(c))&#123;<br>                <span class="hljs-keyword">if</span>(map.containsValue(v[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                map.put(c, v[i]);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!map.get(c).equals(v[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2024/04/24/face_OS1/"/>
    <url>/2024/04/24/face_OS1/</url>
    
    <content type="html"><![CDATA[<h2 id="同步、异步、的概念"><a href="#同步、异步、的概念" class="headerlink" title="同步、异步、的概念"></a>同步、异步、的概念</h2><p><strong>同步</strong>：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。</p><p><strong>异步</strong>：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="3-1-为啥要引入进程的概念？"><a href="#3-1-为啥要引入进程的概念？" class="headerlink" title="3.1 为啥要引入进程的概念？"></a>3.1 为啥要引入进程的概念？</h3><p>程序的封闭性和可再现性。</p><h4 id="程序的并发执行和资源共享"><a href="#程序的并发执行和资源共享" class="headerlink" title="程序的并发执行和资源共享"></a>程序的并发执行和资源共享</h4><p>总的来说就是，多道程序设计的环境下，程序的并发执行代替了程序的顺序执行</p><h4 id="程序并发执行的特性"><a href="#程序并发执行的特性" class="headerlink" title="程序并发执行的特性"></a>程序并发执行的特性</h4><p>增加了系统的处理能力，</p><p>&lt;1&gt;提高了系统的资源利用率但是失去了程序的封闭性，</p><p>&lt;2&gt;程序和机器的执行顺序活动不再是一一对应</p><h4 id="进程概念的引入"><a href="#进程概念的引入" class="headerlink" title="进程概念的引入"></a>进程概念的引入</h4><p>程序的并发执行代替了程序的顺序执行它破坏了程序的封闭性和可再现性，使得程序和计算不再一一对应</p><p>进程的定义：<font color = red>进程是程序的一次执行，该程序可以和其他的程序并发执行（进程是系统进行资源分配和调度的一个独立单位，是系统中的并发执行的单位。）</font></p><ul><li>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</li><li>并发性：任何进程都可以同其他进程一起并发执行</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</li><li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li><li>结构特征：进程由程序、数据和进程控制块三部分组成;</li><li>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果； 但是执行过程中，程序不能发生改变。</li></ul><h3 id="3-1-2-进程的组成"><a href="#3-1-2-进程的组成" class="headerlink" title="3.1.2 进程的组成"></a>3.1.2 进程的组成</h3><p>程序、数据集合、进程控制块（PCB）                                                                                      </p><h4 id="进程调度的状态"><a href="#进程调度的状态" class="headerlink" title="进程调度的状态"></a>进程调度的状态</h4><p><strong>运行状态：</strong>进程已经获得必要的资源，并且占有一个处理机，处理机正在执行该进程的程序。</p><p><strong>就绪状态：</strong>如果进程已经具备了运行的条件，但是由于处理机已经被其他的进程占用，因此暂时不能运行，而是等待分配处理机。</p><p><strong>阻塞状态：</strong>进程在运行的过程中，因为等待某一个事件（如等待某一个输入输出操作的完成而不能运行的状态，称之为阻塞状态，即进程的运行受到了阻塞）</p><p>正在处理机上运行的程序称为该处理机的现运行进程。在任何的时候，一个系统的现运行的进程数一定少于等于可用的处理机的数目。</p><img src = "https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240425122942.png" style="zoom:50%;" ><h2 id="线程及其管理"><a href="#线程及其管理" class="headerlink" title="线程及其管理"></a>线程及其管理</h2><h3 id="3-2-1-线程概念的引入"><a href="#3-2-1-线程概念的引入" class="headerlink" title="3.2.1 线程概念的引入"></a>3.2.1 线程概念的引入</h3><p>操作系统中引入<strong>进程</strong>的目的在于：提高系统的效率，提高系统的资源利用率。</p><p>进程因创建而产生，经调度程序的调度而运行，因等待某一时间而阻塞，最后因任务完成而撤销。也就是说，在进程的整个生存期内，不断地改变它的运行环境。在进程调度的过程中，进程的切换更是常有。在进程进行切换的时候，既要保存现进程的运行环境，又要设置所选中的运行环境。为此要花费不小的处理机的时间。因此将进程作为系统调度的基本单位要付出较大的时空开销，<font color = red >从而限制了系统中进程的数量以及进程切换的频率。</font>从而引进了线程的概念，<font color = red>线程是系统调度的基本单位</font>，但不是独立分配资源的基本单位，使之轻装运行，而对于拥有了资源的基本单位又不频繁的对其进行切换，引进了线程的概念后，既减少了时空的开销，又增强了系统的并行能力。</p><p><font color = red>线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程。</font></p><h3 id="3-2-2-线程和进程的区别"><a href="#3-2-2-线程和进程的区别" class="headerlink" title="3.2.2  线程和进程的区别"></a>3.2.2  线程和进程的区别</h3><blockquote><p>进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；</p><p>创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；</p><p>不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；</p><p>进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；</p></blockquote><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="为什么需要协程？"><a href="#为什么需要协程？" class="headerlink" title="为什么需要协程？"></a>为什么需要协程？</h3><p>我们都知道多线程，当需要同时执行多项任务的时候，就会采用多线程并发执行。拿手机支付举例子，当收到付款信息的时候，需要查询数据库来判断余额是否充足，然后再进行付款。</p><p>假设最开始我们只有可怜的10个用户，收到10条付款消息之后，我们开启启动10个线程去查询数据库，由于用户量很少，结果马上就返回了。第2天用户增加到了100人，你选择增加100个线程去查询数据库，等到第三天，你们加大了优惠力度，这时候有1000人同时在线付款，你按照之前的方法，继续采用1000个线程去查询数据库，并且隐隐觉察到有什么不对。</p><p>几天之后，见势头大好，运营部门开始不停的补贴消费券，展开了史无前例的大促销，你们的用户开始爆炸增长，这时候有10000人同时在线付款，你打算启动10000个线程来处理任务。等等，问题来了，因为每个线程至少会占用4M的内存空间，10000个线程会消耗39G的内存，而服务器的内存配置只有区区8G，这时候你有2种选择，一是选择增加服务器，二是选择提高代码效率。那么是否有方法能够提高效率呢？</p><p>我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<font color = red><strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></font></p><p>协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<font color = red><strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong></font>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p><p>回到上面的问题，我们只需要启动100个线程，每个线程上运行100个协程，这样不仅减少了线程切换开销，而且还能够同时处理10000个读取数据库的任务，很好的解决了上述任务。</p><p>知道了协程的工作方式，那么我们再看下使用协程有哪些注意事项。</p><h3 id="协程的注意事项"><a href="#协程的注意事项" class="headerlink" title="协程的注意事项"></a>协程的注意事项</h3><p>实际上协程并不是什么银弹，协程只有在等待IO的过程中才能重复利用线程，上面我们已经讲过了，线程在等待IO的过程中会陷入阻塞状态，意识到问题没有？</p><p>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，<strong>因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></p><p>因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。</p><p>那么如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：</p><ol><li><strong>在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。这其实和多线程没有太大区别。</strong></li><li><strong>对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。</strong></li></ol><p>协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。</p><p>以上就是协程的注意事项。这里顺带一提JavaScript的异步变同步的调用方式，如果协程能够实现该类型的语法，不仅可以把异步操作变为同步，同时在IO操作的时候还能够不占用CPU，写起来非常方便。</p><p><strong>异步变同步的调用方式只是一种编程方式，不管是用线程还是用协程都可以实现这种编程方式，好处是不用在处理非常多的回调。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。</p><p>在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。</p><p><strong>协程只有和异步IO结合起来才能发挥出最大的威力。</strong></p><p>协程就是java的虚拟线程</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="1、死锁的起因"><a href="#1、死锁的起因" class="headerlink" title="1、死锁的起因"></a>1、死锁的起因</h3><p>一个进程在其运行的过程中可以提出使用多个资源的要求，仅当全部的资源都可以满足的时候，进程才能继续运行而到达终点，否则该进程因得不到所要求的资源而处于阻塞的状态，当两个或者两个以上的进程同时对于多个互斥资源提出使用的请求的时候，才可能导致死锁。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240424224939.png" style="zoom:50%;" /><h3 id="2、产生死锁的必要条件"><a href="#2、产生死锁的必要条件" class="headerlink" title="2、产生死锁的必要条件"></a>2、产生死锁的必要条件</h3><ul><li>互斥控制。进程对其要求的资源进行排他控制，一个资源仅仅能被一个进程独占</li><li>非剥夺控制。进程所获得的资源在未被释放之前，不能被其他的进程剥夺，即该进程处于阻塞的状态，它所占用的资源也不能被其他的进程使用，而其他的进程也只能等待该资源的释放。</li><li>逐次请求。进程以随意的零星的方式逐次取得资源，而不是集中的一次请求，这样有利于提高资源的利用率。</li><li>环路条件。在发生死锁的时候，其有向图必然构成环路，即前一个进程保持着后一个进程所要求的资源。</li></ul><p>只要破坏上述条件之一，即可预防死锁的发生</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试必背</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程2</title>
    <link href="/2024/04/22/JUC-03-2/"/>
    <url>/2024/04/22/JUC-03-2/</url>
    
    <content type="html"><![CDATA[<h2 id="3-5-线程中的常见方法"><a href="#3-5-线程中的常见方法" class="headerlink" title="3.5 线程中的常见方法"></a>3.5 线程中的常见方法</h2><table><thead><tr><th>方法</th><th>（static）功能说明</th><th>注意</th></tr></thead><tbody><tr><td>start()</td><td>启动一个线程，在新的线程运行run方法中的代码。</td><td>start()方法只是让线程进入就绪状态，里面的代码不一定就立刻运行（任务调度器决定）（CPU的时间片还没有分给它）。线程对象的start方法只能调用一次，如果调用了多次会出现<code>illegalThreadStateException</code>。</td></tr><tr><td>run()</td><td>新的线程启动后会调用的代码。</td><td>如果在构造了Thread方法时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何的参数。但是可以创建Thread的子类对象，来覆盖默认行为。</td></tr><tr><td>join()</td><td>等待线程运行结束。</td><td>两个线程之间通信时候使用</td></tr><tr><td>join(long n)</td><td>等待线程运行结束，最多等待n秒。</td><td></td></tr><tr><td>getId()</td><td>获取线程的长整型的id</td><td>id唯一</td></tr><tr><td>getName()</td><td>获取线程名</td><td></td></tr><tr><td>setName(String)</td><td>修改线程名</td><td></td></tr><tr><td>getPriority()</td><td>获取线程优先级</td><td></td></tr><tr><td>setPriority(int)</td><td>修改线程的优先级</td><td>java中规定线程的优先级是1~10的整数。较大的优先级能够提高该线程被CPU调度的几率</td></tr><tr><td>getStart()</td><td>获取线程的状态</td><td>Java 中线程状态是用6个enum表示，分别为：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TermInated</td></tr><tr><td>isInterrupted()</td><td>判断是否会被打断</td><td>不会清除<code>打断标记</code></td></tr><tr><td>isAlive()</td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td>interrupt()</td><td>打断线程</td><td>如果被打断的线程正在sleep、wait、join会导致被打断的线程抛出interruptedException，并清除打断标记；如果打断正在运行的线程，则会设置打断标记，park的线程也会被打断，也会设置<code>打断标记</code></td></tr><tr><td>interrupted()</td><td>(static)判断当前线程是否被打断</td><td>会清除<code>打断标记</code></td></tr><tr><td>currentThread()</td><td>(static) 获取当前正在执行的线程</td><td></td></tr><tr><td>sleep(long n)</td><td>(static) 让当前执行的线程休眠n毫秒，休眠时让出CPU的时间片给其他线程。</td><td></td></tr><tr><td>yield</td><td>(static) 提示线程调度器让出当前线程对于CPU的调度</td><td>主要是为了测试和调试</td></tr></tbody></table><h2 id="3-6-Start与run"><a href="#3-6-Start与run" class="headerlink" title="3.6 Start与run"></a>3.6 Start与run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test05&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running......&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//只是调用了该线程类的普通方法而已，并没有启动t1线程</span><br>        t1.run();<br>        <span class="hljs-comment">//启动了t1线程</span><br>        t1.start();<br>        log.debug(<span class="hljs-string">&quot;do other things......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接调用run方法并没有启动新的线程，他还是在主线程来调用了run方法。相当于创建一个对象直接调用，没有开启线程。</p><p>Thread类中的start方法调用的是native方法，也就是C++方法，由操作系统来new线程。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240406105753.png" style="zoom:50%;" />              <img src="C:\Users\17083\AppData\Roaming\Typora\typora-user-images\image-20240406105905327.png" alt="image-20240406105905327" style="zoom: 50%;" /></p><p>new表示线程处于一个新建的状态还没有被CPU运行，而在线程启动（<code>t1.start()</code>）以后再去打印，打印的是runnable，表示可以被cpu所调度执行。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240406111252.png" style="zoom:50%;" /><h2 id="3-7-Sleep与yield"><a href="#3-7-Sleep与yield" class="headerlink" title="3.7 Sleep与yield"></a>3.7 Sleep与yield</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ul><li><p>调用sleep方法会让线程从running 进入Timed Waiting状态（阻塞）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test07&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.start();<br>        <span class="hljs-comment">//首先打印RUNNABLE的原因是：主线程的代码先运行，先运行以后t1线程再运行，</span><br>        <span class="hljs-comment">//t1线程运行以后他还没有进入休眠状态，这时候主线程的t1.getState()就已经执行了</span><br>        log.debug(<span class="hljs-string">&quot;t1的state是：&quot;</span>+t1.getState());<br>        <span class="hljs-comment">//休眠主线程</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//主线程等了500ms之后t1线程进入了休眠状态</span><br>        log.debug(<span class="hljs-string">&quot;t1的state是：&quot;</span>+t1.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出interruptedException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test08&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;Enter Sleeping......&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;wake up&quot;</span>);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;interrupt...&quot;</span>);<br>        t1.interrupt();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>睡眠结束以后的线程未必会立刻得到执行（也许CPU正在执行其他的代码，等任务调度器将新的时间片分给线程以后才能运行）</p></li><li><p>建议使用TimeUnit的sleep代替Thread的Sleep来获得更好的可读性</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240406145930.png" style="zoom:50%;" /></li></ul><h4 id="sleep案例-防止CPU占用100"><a href="#sleep案例-防止CPU占用100" class="headerlink" title="sleep案例 - 防止CPU占用100%"></a>sleep案例 - 防止CPU占用100%</h4><p>Sleep实现</p><p>在没有利用CPU来进行计算的时候，不要让while(true)空转来浪费CPU，这时候可以使用yield或者sleep来让出CPU的使用权给其他程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以利用wait或条件变量达到类似的效果</li><li>不同的是后两者都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场所</li><li>sleep适用于无需锁同步的场景</li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>调用yield会让当前线程从Running进入Runnable就绪状态，然后调度执行其他同优先级的线程。如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果。（有时候会出现想让但是没有让出去的情况）</li><li>具体的实现依赖操作系统的任务调度器</li></ul><h3 id="yield和sleep的区别"><a href="#yield和sleep的区别" class="headerlink" title="yield和sleep的区别"></a>yield和sleep的区别</h3><p>sleep和yield看起来都是让线程暂时先不要运行，将机会让给其他线程。</p><ul><li>就绪状态<code>Runnable</code>还是有机会被任务调度器调度的。就绪状态，任务调度器还是会分时间片给就绪状态的</li><li>阻塞状态<code>Timed Waiting</code>任务调度器不会将时间片分给阻塞状态。</li></ul><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul><li>线程优先级会提示调度器优先调度该线程，但他仅仅是一个提示（并不靠谱），调度器可以忽略它。</li><li>如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但是cpu闲时，优先级几乎没有作用。</li></ul><p>不论是<code>yield</code>还是<code>sleep</code>都不能真正的去控制线程的调度，他们最终还是由操作系统的任务调度器来决定最终哪一个线程分到更多的时间片，他们都是给任务调度器一个提示而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test10</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> () -&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (;;)&#123;<br>                System.out.println(<span class="hljs-string">&quot;-----&gt;1   &quot;</span> + count++);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; ;)&#123;<br>                <span class="hljs-comment">//将CPU时间片分给task1</span><br><span class="hljs-comment">//                Thread.yield();</span><br>                System.out.println(<span class="hljs-string">&quot;            -----&gt;2   &quot;</span> + count++);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task1, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.setPriority(Thread.MIN_PRIORITY);<br>        t2.setPriority(Thread.MAX_PRIORITY);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8-join方法详解"><a href="#3-8-join方法详解" class="headerlink" title="3.8 join方法详解"></a>3.8 join方法详解</h2><h3 id="为啥要使用join"><a href="#为啥要使用join" class="headerlink" title="为啥要使用join?"></a>为啥要使用join?</h3><p>这里先看一段程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test11&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test11</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        test1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>            r =<span class="hljs-number">100</span>;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        log.debug(<span class="hljs-string">&quot;结果为：&#123;&#125;&quot;</span>,r);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此程序的结果为</p><pre><code class="hljs">  DEBUG [main] (Test11.java:12) - 开始  DEBUG [t1] (Test11.java:14) - 开始  DEBUG [main] (Test11.java:24) - 结果为：0  DEBUG [main] (Test11.java:25) - 结束  DEBUG [t1] (Test11.java:20) - 结束一、主方法执行test1（显然主线程在执行test1,）打印了开始几乎与此同时线程1被启动了，打印了线程1中的开始（从打印的时间或先后顺序上看的）二、分析先打印主线程的开始（因为主线程开始启动的时候，t1还没开始启动呢，然后t1又休眠了，那主线程结束也肯定比t1结束的快一些），这时候已经来不及获取r的值了，所以R的输出结果为0，在t1线程需要1s之后才能算出r = 10</code></pre><p>如何解决获取r &#x3D; 100的这个值呢？</p><ul><li>使用sleep（主线程休眠）可以吗？         （行但是不完全行，时间不好把握）</li><li>用join，夹在t1.start()之后即可</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG [main] (Test11.java:23) - 开始<br>DEBUG [t1] (Test11.java:25) - 开始<br>DEBUG [t1] (Test11.java:31) - 结束<br>DEBUG [main] (Test11.java:36) - 结果为：100<br>DEBUG [main] (Test11.java:37) - 结束<br></code></pre></td></tr></table></figure><h3 id="应用之同步（案例1）"><a href="#应用之同步（案例1）" class="headerlink" title="应用之同步（案例1）"></a>应用之同步（案例1）</h3><p>从调用的角度上来讲，如果</p><ul><li>需要等待结果的返回，才能继续运行就是同步</li><li>不需要等待返回的结果，就能继续运行就是异步</li></ul><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/b05305b8bd0ecbb7e684610a27b048ba.png" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test12&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test12</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        test2();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            r1 = <span class="hljs-number">10</span>;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            r2 = <span class="hljs-number">20</span>;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">//计时</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        log.debug(<span class="hljs-string">&quot;join begin&quot;</span>);<br>        t1.join();<br>        log.debug(<span class="hljs-string">&quot;t1 join end&quot;</span>);<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;t2 join end&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">//这里有一个问题这个时间差到底是多少呢？ 2s</span><br>        log.debug(<span class="hljs-string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>,r1 , r2,end-start);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的分析如下所示：</p><ul><li>第一个join：等待t1时候，t2并没有停止，而是在运行</li><li>第二个join：1s后，执行到此，t2也运行了1s，因此也只需要再等待1s</li></ul><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/Screenshot_2024-04-09-23-00-13-922_tv.danmaku.bil.png" style="zoom:50%;" /><h2 id="3-9-interrupt方法详解"><a href="#3-9-interrupt方法详解" class="headerlink" title="3.9 interrupt方法详解"></a>3.9 interrupt方法详解</h2><h3 id="打断sleep，wait，join的线程"><a href="#打断sleep，wait，join的线程" class="headerlink" title="打断sleep，wait，join的线程"></a>打断sleep，wait，join的线程</h3><p>阻塞</p><p>打断sleep的线程，会清空打断状态，以sleep为例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test14&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test14</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        test1();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;sleep.......&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;interrupt&quot;</span>);<br>        t1.interrupt();<br>        log.debug(<span class="hljs-string">&quot;打断标记：&#123;&#125;&quot;</span>,t1.isInterrupted());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">DEBUG [t1] (Test14.java:<span class="hljs-number">14</span>) - sleep.......<br>DEBUG [main] (Test14.java:<span class="hljs-number">23</span>) - interrupt<br>DEBUG [main] (Test14.java:<span class="hljs-number">25</span>) - 打断标记：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h3><p>打断标记的用途：打断的状态可以用来停止线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test15&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> Thread.currentThread().isInterrupted();<br>                <span class="hljs-comment">//对于正常运行的线程如果被其他线程打断之后,布尔值会变成true</span><br>                <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                    log.debug(<span class="hljs-string">&quot;被打断了，退出了循环&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//主线程睡眠一秒</span><br>        log.debug(<span class="hljs-string">&quot;interrupt&quot;</span>);<br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-11-主线程与守护线程"><a href="#3-11-主线程与守护线程" class="headerlink" title="3.11 主线程与守护线程"></a>3.11 主线程与守护线程</h2><p>默认的情况下，java线程需要等待所有的线程都运行结束，才会结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test17</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG [main] (Test17.java:19) - 结束<br></code></pre></td></tr></table></figure><p>有一种特殊的线程叫做守护线程，只要其他的非守护线程结束了，即使守护线程的代码没有执行完毕，也会强制结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test17</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">//将t1设置为守护线程</span><br>        t1.setDaemon(<span class="hljs-literal">true</span>);<br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG [main] (Test17.java:19) - 结束<br></code></pre></td></tr></table></figure><p>垃圾回收器就是一种守护线程</p><p>Tomcat中的Acceptor和poller线程都属于守护线程（Tomcat用来接收请求和分发请求的线程），所以Tomcat接收到shutdown命令后，不会等待他们（Acceptor和poller）处理完当前的请求（强制结束）。</p><h2 id="3-1-2-五种状态"><a href="#3-1-2-五种状态" class="headerlink" title="3.1.2 五种状态"></a>3.1.2 五种状态</h2><p>从操作系统层面来描述的</p><pre><code class=" mermaid">graph TBA[初始状态] --&gt; B[可运行的状态]B --&gt; C[运行状态]C --&gt; D[终止状态]C --&gt; BE --&gt; BG((CPU)) --&gt; CC --&gt; E[阻塞状态]</code></pre><ul><li>【初始状态】仅仅是在语言层面创建了线程对象，还未与操作系统相互关联（只是在对象的层面new了一个对象）</li><li>【可运行的状态】（就绪状态）指的是该线程已经被创建了（与操作系统相互关联），还可以由CPU调度执行，暂时没有获得CPU的时间片</li><li>【运行状态】指的是获取了CPU时间片运行中的状态</li><li>当cpu时间片运行完，会从【运行状态】–&gt;【可运行的状态】，会导致线程上下文切换，</li><li>【阻塞状态】<ul><li>如果调用了阻塞的API，如BIO读写文件，这时线程不会实际使用到CPU，会导致线程上下文切换，进入了【阻塞状态】</li><li>等到BIO执行完，会由操作系统唤醒阻塞的线程，转换至【可运行的状态】</li><li>与可运行状态的区别是，对于阻塞状态的线程来说只要一直不唤醒，调度器就一直不会考虑调度他们</li></ul></li><li>终止状态 ：线程已经执行完毕，生命周期结束，不会转化为其他的状态</li></ul><h2 id="3-1-3六种状态"><a href="#3-1-3六种状态" class="headerlink" title="3.1.3六种状态"></a>3.1.3六种状态</h2><p>这是根据JAVA API来描述的</p><p>根据Thread State枚举，分为六种状态</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/1e4cc6a0014f5a31c284d406bea5d1a2.png" style="zoom:50%;" /><h2 id="3-1-4-习题"><a href="#3-1-4-习题" class="headerlink" title="3.1.4 习题"></a>3.1.4 习题</h2><p>阅读华罗庚《统筹方法》，<br>给出烧水泡茶的多线程解决方案，提示</p><ul><li><p>参考图二，用两个线程(两个人协作)模拟烧水泡茶过程</p><ul><li>文中办法乙、丙都相当于任务串行</li><li>而图一相当于启动了4个线程，有点浪费</li></ul></li><li><p>用sleep(n)模拟洗茶壶、洗水壶等耗费的时间</p></li></ul><p>华罗庚《统筹方法》<br>附:</p><ul><li><p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关<br>系复杂的科研项目的组织与管理中，都可以应用。<br>怎样应用呢?主要是把工序安排好<br>比如，想泡壶茶喝。当时的情况是:开水没有;水壶要洗，茶壶、茶杯要洗，火已生了，茶叶也有了<br>怎么办?</p><ul><li>办法甲:洗好水壶，灌上凉水，放在火上;在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶，等水开<br>了，泡茶喝。</li><li>办法乙:先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶;一切就绪，灌水烧水;坐待水开了<br>泡茶喝。</li><li>办法丙:洗净水壶，灌上凉水，放在火上，坐待水开，水开了之后，急急忙忙找茶叶，洗茶壶茶杯<br>泡茶喝。</li></ul><p>哪一种方法省时间？一眼便可以看得出，第一种方法好</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test17&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test17</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;洗水壶&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                log.debug(<span class="hljs-string">&quot;烧开水&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;老王&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;洗茶壶&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                log.debug(<span class="hljs-string">&quot;清洗茶叶杯子&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                log.debug(<span class="hljs-string">&quot;拿茶叶&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;泡茶叶&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;小王&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG [老王] (Test17.java:7) - 洗水壶<br>DEBUG [小王] (Test17.java:18) - 洗茶壶<br>DEBUG [老王] (Test17.java:10) - 烧开水<br>DEBUG [小王] (Test17.java:21) - 清洗茶叶杯子<br>DEBUG [小王] (Test17.java:23) - 拿茶叶<br>DEBUG [小王] (Test17.java:29) - 泡茶叶<br></code></pre></td></tr></table></figure><ul><li>上述的模拟是小的等老的水烧开了之后，小的泡茶，如果反过来要等老王等小王的茶叶拿来，老王泡茶叶呢？代码最好可以使用两种情况</li><li>上面的线程其实就是各执行各的如果要模拟老的将茶壶交给小的泡茶叶，或者模拟小王将茶叶交给老王泡茶叶呢？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 394场周赛</title>
    <link href="/2024/04/21/week_match001/"/>
    <url>/2024/04/21/week_match001/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/count-the-number-of-special-characters-i/description/">100294. 统计特殊字母的数量 I - 力扣（LeetCode）</a></p><p>这个简单题被我拿下了:blush:但是耗费了我好长好长的时间，到底是API使用的不够熟练</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSpecialChars</span><span class="hljs-params">(String word)</span> &#123;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray()) set.add(c);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Character c : set)&#123;<br>            <span class="hljs-keyword">if</span> (Character.isLowerCase(c) &amp;&amp; set.contains(Character.toUpperCase(c)))&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-the-number-of-special-characters-ii/description/">100291. 统计特殊字母的数量 II - 力扣（LeetCode）</a></p><p>这个题目花了我也是费劲了老长的时间，但是没有拿的下来，可能水平就到这里了:sob:</p><p>HashMap如果加入了相同的<code>KEY</code>，后面加入的&lt;KEY，VALUE&gt;会覆盖掉前面的</p><p>putIfAbsent() 方法会先判断指定的键（key）是否存在，不存在则将键&#x2F;值对插入到 HashMap 中。</p><p>但是这个方法进行判断不会覆盖掉前面的键值对</p><p><strong>注意：</strong>如果指定 key 之前已经和一个 null 值相关联了 ，则该方法也返回 null。</p><p>我的大致的思路和这个基本一致:sob::sob::sob:</p><p>只需要记住大写字母第一次出现的位置以及小写字母最后一次出现的位置就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSpecialChars</span><span class="hljs-params">(String word)</span> &#123;<br>        Map&lt;Character, Integer&gt; upperCaseStart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; lowerCaseEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">if</span>(Character.isUpperCase(c))&#123;<br>                upperCaseStart.putIfAbsent(c, i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                lowerCaseEnd.put(c, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> <span class="hljs-variable">upper</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>, lower = <span class="hljs-string">&#x27;a&#x27;</span>; upper &lt;=<span class="hljs-string">&#x27;Z&#x27;</span>; upper++, lower++)&#123;<br>            <span class="hljs-keyword">if</span>(upperCaseStart.containsKey(upper) &amp;&amp; lowerCaseEnd.containsKey(lower) &amp;&amp; upperCaseStart.get(upper) &gt; lowerCaseEnd.get(lower))&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-satisfy-conditions/description/">100290. 使矩阵满足条件的最少操作次数 - 力扣（LeetCode）</a></p><p>这个题目我都没有时间去看:sob:真他妈难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>        <span class="hljs-comment">// 统计每一列中每个数字的出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            Arrays.fill(count[j], <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>                ++count[j][grid[i][j]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = m - count[<span class="hljs-number">0</span>][j];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">minOps</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; j != k) &#123;<br>                        minOps = Math.min(minOps, dp[i - <span class="hljs-number">1</span>][k]);<br>                    &#125;<br>                &#125;<br>                dp[i][j] = minOps + (m - count[i][j]); <span class="hljs-comment">// 当前列选择数字 j 的最小操作数</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算总的最小操作数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j) &#123;<br>            ans = Math.min(ans, dp[n - <span class="hljs-number">1</span>][j]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的大题是一个图的一个题目，做不来</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数与位2</title>
    <link href="/2024/04/20/%E6%95%B0%E4%B8%8E%E4%BD%8D2/"/>
    <url>/2024/04/20/%E6%95%B0%E4%B8%8E%E4%BD%8D2/</url>
    
    <content type="html"><![CDATA[<h1 id="数字的位操作2"><a href="#数字的位操作2" class="headerlink" title="数字的位操作2"></a>数字的位操作2</h1><p><a href="https://leetcode.cn/problems/power-of-two/description/">231. 2 的幂 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-keyword">return</span> ( n &gt; <span class="hljs-number">0</span>&amp;&amp;( n &amp; (n - <span class="hljs-number">1</span>))== <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/power-of-four/description/">342. 4的幂 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> ((n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp;  (n &amp; (<span class="hljs-number">0xaaaaaaaa</span>)) == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/power-of-three/description/">326. 3 的幂 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x != n)&#123;<br>            x *= <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span>(x &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1162261467是3 ^ 19</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-number">1162261467</span> % n) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/base-7/description/">504. 七进制数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convertToBase7</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">negative</span> <span class="hljs-operator">=</span> num &lt; <span class="hljs-number">0</span>;<br>        num = Math.abs(num);<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">digits</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>            digits.append(num % <span class="hljs-number">7</span>);<br>            num /= <span class="hljs-number">7</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(negative) digits.append(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">return</span> digits.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ugly-number/description/">263. 丑数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUgly</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[] v = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> g : v)&#123;<br>            <span class="hljs-keyword">while</span>(n % g == <span class="hljs-number">0</span>)&#123;<br>                n /= g;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-closest-palindrome/description/">564. 寻找最近的回文数 - 力扣（LeetCode）</a></p><p>这个题目我用暴力超时了，但是题解方法太难了，过几天再写吧</p><p>暴力超时法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nearestPalindromic</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;1&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br><span class="hljs-type">long</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">10</span> ,n + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">a0</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x; i++)&#123;<br><span class="hljs-keyword">if</span>(judge(i)) &#123;<br>a0 = Math.max(a0, i);<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> y; i &gt; x; i--)&#123;<br><span class="hljs-keyword">if</span>(judge(i))&#123;<br>a1 = Math.min(a1, i);<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">ret0</span> <span class="hljs-operator">=</span> Math.abs(x - a0);<br><span class="hljs-type">long</span> <span class="hljs-variable">ret1</span> <span class="hljs-operator">=</span> Math.abs(x - a1);<br><span class="hljs-keyword">return</span> ret0 &gt; ret1 ? String.valueOf(a1) : String.valueOf(a0);<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">revert</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x &gt; revert)&#123;<br>            revert = revert*<span class="hljs-number">10</span> + x%<span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == revert || x == revert/<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数与位</title>
    <link href="/2024/04/18/%E6%95%B0%E4%B8%8E%E4%BD%8D1/"/>
    <url>/2024/04/18/%E6%95%B0%E4%B8%8E%E4%BD%8D1/</url>
    
    <content type="html"><![CDATA[<h1 id="数字的位操作"><a href="#数字的位操作" class="headerlink" title="数字的位操作"></a>数字的位操作</h1><p><a href="https://leetcode.cn/problems/reverse-integer/">7. 整数反转 - 力扣（LeetCode）</a></p><p>有一点东西，但不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> x % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">214748364</span> || (res == <span class="hljs-number">214748364</span> &amp;&amp; v &gt; <span class="hljs-number">7</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res &lt; -<span class="hljs-number">214748364</span> || (res == -<span class="hljs-number">214748364</span>) &amp;&amp; v &lt; -<span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            x /= <span class="hljs-number">10</span>;<br>            res = res*<span class="hljs-number">10</span> + v;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-number/">9. 回文数 - 力扣（LeetCode）</a></p><p>这种方法就是练一下kmp算法，主要是这东西我写一次，错一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(x);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span> + s;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; ss.charAt(j + <span class="hljs-number">1</span>) != ss.charAt(i)) j = next[j];<br>            <span class="hljs-keyword">if</span>(ss.charAt(j + <span class="hljs-number">1</span>) == ss.charAt(i)) next[i] = ++j;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span> &amp;&amp; ss.charAt(len + <span class="hljs-number">1</span>) != ss.charAt(i)) len = next[len];<br>            <span class="hljs-keyword">if</span>(ss.charAt(len + <span class="hljs-number">1</span>) == ss.charAt(i)) len++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/largest-palindrome-product/description/">479. 最大回文数乘积 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>        <span class="hljs-comment">//选一个n位数字中最大的值，从大到小逐个遍历</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> max; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i, b = i;<br>            <span class="hljs-comment">//构造一个回文数</span><br>            <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>                a = a*<span class="hljs-number">10</span> + b%<span class="hljs-number">10</span>;<br>                b /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-comment">//j至少要保证 j^2是大于构造的回文数（a）的,否则j*(j - 1)就一定小于a</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> max; j * j &gt; a; j--)&#123;<br>                <span class="hljs-keyword">if</span>(a % j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(a % <span class="hljs-number">1337</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 128场双周赛</title>
    <link href="/2024/04/14/week_match_Double001/"/>
    <url>/2024/04/14/week_match_Double001/</url>
    
    <content type="html"><![CDATA[<h1 id="LC-128场双周赛"><a href="#LC-128场双周赛" class="headerlink" title="LC 128场双周赛"></a>LC 128场双周赛</h1><h3 id="100280-覆盖所有点的最少矩形数目-力扣（LeetCode）"><a href="#100280-覆盖所有点的最少矩形数目-力扣（LeetCode）" class="headerlink" title="100280. 覆盖所有点的最少矩形数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-rectangles-to-cover-points/description/">100280. 覆盖所有点的最少矩形数目 - 力扣（LeetCode）</a></h3><p>给你一个二维整数数组 <code>point</code> ，其中 <code>points[i] = [xi, yi]</code> 表示二维平面内的一个点。同时给你一个整数 <code>w</code> 。你需要用矩形 <strong>覆盖所有</strong> 点。</p><p>每个矩形的左下角在某个点 <code>(x1, 0)</code> 处，且右上角在某个点 <code>(x2, y2)</code> 处，其中 <code>x1 &lt;= x2</code> 且 <code>y2 &gt;= 0</code> ，同时对于每个矩形都 <strong>必须</strong> 满足 <code>x2 - x1 &lt;= w</code> 。</p><p>如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。</p><p>请你在确保每个点都 <strong>至少</strong> 被一个矩形覆盖的前提下，<strong>最少</strong> 需要多少个矩形。</p><p><strong>注意：</strong>一个点可以被多个矩形覆盖。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240413225051.png" style="zoom:50%;" /><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240413225135.png" alt="50、、" style="zoom:50%;" /><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240413225544.png" alt="50%" style="zoom:50%;" /></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 105</code></li><li><code>points[i].length == 2</code></li><li><code>0 &lt;= xi == points[i][0] &lt;= 109</code></li><li><code>0 &lt;= yi == points[i][1] &lt;= 109</code></li><li><code>0 &lt;= w &lt;= 109</code></li><li>所有点坐标 <code>(xi, yi)</code> 互不相同。</li></ul><p>可以这样进行理解最后答案的数目与高度是没有啥关系的（可以将它想象成一条线上的点），所以按照第一列的大小顺序进行排序，当每一次的宽度够不到下一个点的左区间的时候+w，同时ans + 1，如此反复贪心下去（但就是想不到）</p><p>如果这么写的话有一些像我之前写过的区间合并了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minRectanglesToCoverPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points, <span class="hljs-type">int</span> w)</span> &#123;<br>        <span class="hljs-comment">//按照第一列的大小顺序进行排序</span><br>Arrays.sort(points, (a, b) -&gt;(a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, mx = -<span class="hljs-number">1</span>, n = points.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; mx)&#123;<br>                ans += <span class="hljs-number">1</span>;<br>                mx = points[i][<span class="hljs-number">0</span>] + w;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="100273-边界元素是最大值的子数组数目-力扣（LeetCode）"><a href="#100273-边界元素是最大值的子数组数目-力扣（LeetCode）" class="headerlink" title="100273. 边界元素是最大值的子数组数目 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/description/">100273. 边界元素是最大值的子数组数目 - 力扣（LeetCode）</a></h3><p>给你一个 <strong>正</strong> 整数数组 <code>nums</code> 。请你求出 <code>nums</code> 中有多少个子数组，满足子数组中 <strong>第一个</strong> 和 <strong>最后一个</strong> 元素都是这个子数组中的 <strong>最大</strong> 值。</p><p><strong>示例 1：</strong>                                                                                                                  </p><p><strong>输入：</strong>nums &#x3D; [1,4,3,3,2]</p><p><strong>输出：</strong>6</p><p><strong>解释：</strong></p><p>总共有 6 个子数组满足第一个元素和最后一个元素都是子数组中的最大值：</p><ul><li>子数组 [<em><strong>1</strong></em>,4,3,3,2]，最大元素为 1 ，第一个和最后一个元素都是 1 。</li><li>子数组 [1,<em><strong>4</strong></em>,3,3,2] ，最大元素为 4 ，第一个和最后一个元素都是 4 。</li><li>子数组 [1,4,<em><strong>3</strong></em>,3,2] ，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [1,4,3,<em><strong>3</strong></em>,2]，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [1,4,3,3,<em><strong>2</strong></em>] ，最大元素为 2 ，第一个和最后一个元素都是 2 。</li><li>子数组 [1,4,<em><strong>3,3</strong></em>,2] ，最大元素为 3 ，第一个和最后一个元素都是 3 。</li></ul><p>所以我们返回 6 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums &#x3D; [3,3,3]</p><p><strong>输出：</strong>6</p><p><strong>解释：</strong></p><p>总共有 6 个子数组满足第一个元素和最后一个元素都是子数组中的最大值：</p><ul><li>子数组 [<em><strong>3</strong></em>,3,3]，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [3,<em><strong>3</strong></em>,3] ，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [3,3,<em><strong>3</strong></em>]，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [<em><strong>3,3</strong></em>,3] ，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [3,<em><strong>3,3</strong></em>] ，最大元素为 3 ，第一个和最后一个元素都是 3 。</li><li>子数组 [<em><strong>3,3,3</strong></em>] ，最大元素为 3 ，第一个和最后一个元素都是 3 。</li></ul><p>所以我们返回 6 。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>nums &#x3D; [1]</p><p><strong>输出：</strong>1</p><p><strong>解释：</strong></p><p><code>nums</code> 中只有一个子数组 [<em><strong>1</strong></em>] ，最大元素为 1 ，第一个和最后一个元素都是 1 。</p><p>所以我们返回 1 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><p>当遍历数组<code>nums</code>时，我们使用双端队列<code>st</code>来存储当前遍历到的元素的最大值及其出现次数。这样，在遍历过程中，我们可以快速地找到当前子数组的最大值，并更新答案<code>ans</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums.length;<br>Deque&lt;<span class="hljs-type">int</span>[]&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>st.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;Integer.MAX_VALUE, <span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br><span class="hljs-keyword">while</span>(x &gt; st.peek()[<span class="hljs-number">0</span>]) st.pop();<br><span class="hljs-keyword">if</span>(x == st.peek()[<span class="hljs-number">0</span>])&#123;<br>ans += st.peek()[<span class="hljs-number">1</span>]++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>st.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, <span class="hljs-number">1</span>&#125;);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程1</title>
    <link href="/2024/04/10/JUC-03-1/"/>
    <url>/2024/04/10/JUC-03-1/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1创建线程以及运行线程"><a href="#3-1创建线程以及运行线程" class="headerlink" title="3.1创建线程以及运行线程"></a>3.1创建线程以及运行线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="方法一：直接使用线程"><a href="#方法一：直接使用线程" class="headerlink" title="方法一：直接使用线程"></a>方法一：直接使用线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j(topic =  &quot;c.Test01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.start();<br>        t.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二：使用runnable配合Thread"><a href="#方法二：使用runnable配合Thread" class="headerlink" title="方法二：使用runnable配合Thread"></a>方法二：使用runnable配合Thread</h4><p>把【线程】和【任务】需要执行的代码分开</p><p><code>Thread</code>代表线程</p><p><code>runnable</code>代表可运行的任务（线程需要执行的代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test02&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码可以使用<code>Lambda表达式</code>进行简化</p><h4 id="Thread与Runnable之间的关系"><a href="#Thread与Runnable之间的关系" class="headerlink" title="Thread与Runnable之间的关系"></a>Thread与Runnable之间的关系</h4><p>分析一下Thread与Runnable之间的关系</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240325175731.png"></p><p>runnable对象作为参数传给了Thread的构造方法，其中又调用了init方法，然后又被传给了一个重载的Init()方法，最后发现<code>this.target = target;</code>实际上就是将Runnable对象赋值给了Thread中的一个成员变量</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240325180236.png" style="zoom:50%;" /><p>方法二实际上走的还是人家Thread 的run方法，如果你有target(runnable)对象，采用runnable对象的run方法。不论是方法一还是方法二，将来线程运行时候，走的都是线程对象中的run方法。</p><ul><li>方法一就是将线程和任务合并在一块了，方法二是将线程和任务分开了。</li><li>用Runnable更更容易与线程池等高级API配合使用</li><li>用Runnable让任务脱离了Thread继承体系，更灵活。实际上这两就是组合的关系。</li></ul><h4 id="方法三：FutureTask配合Thread"><a href="#方法三：FutureTask配合Thread" class="headerlink" title="方法三：FutureTask配合Thread"></a>方法三：FutureTask配合Thread</h4><ul><li>FutureTask能够接收Callable类型地参数，用来处理有返回结果的情况</li></ul><p>FutureTask是runnable的一个扩展，可以用来获取任务的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <br></code></pre></td></tr></table></figure><p>他是一个实现类实现了RunnableFuture的一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt; <br></code></pre></td></tr></table></figure><p>它间接实现了runnable接口，它可以作为一个任务对象，它比Runnable多了一个future接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; <br></code></pre></td></tr></table></figure><p>future用来返回任务的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br></code></pre></td></tr></table></figure><p>就是这个get方法。</p><p>但是Runnable接口返回值是一个void，所以它并不能方便地在两个线程直接把一个结果传给另外一个线程。</p><p>Callable和runnable接口非常像，但是它是有返回值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;cTest03&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">10000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">//等待task返回一个结果（阻塞），主线程阻塞读取返回值</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2观察多个线程同时执行"><a href="#3-2观察多个线程同时执行" class="headerlink" title="3.2观察多个线程同时执行"></a>3.2观察多个线程同时执行</h2><p>主要是理解</p><ul><li>交替执行</li><li>谁先谁后，不由得我们控制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">practice1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-查看进程的方法"><a href="#3-3-查看进程的方法" class="headerlink" title="3.3 查看进程的方法"></a>3.3 查看进程的方法</h2><p><strong>Windows</strong></p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist</li><li>taskkill</li></ul><p><strong>Linux查看进程和查看线程的信息</strong></p><ul><li>ps -fe 查看所有的进程信息</li></ul><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326121000.png" style="zoom:50%;" /><ul><li>ps -fT -p <PID>  查看某个进程（PID）的所有线程</li></ul><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326121252.png"></p><ul><li>kill 杀死进程</li></ul><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326121552.png"></p><ul><li>top 按下大写H是否切换线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程（看哪一个进程的线程）</li></ul><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326121951.png" style="zoom:50%;" /><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326122116.png" style="zoom:50%;" /><p><strong>Java</strong></p><ul><li>jps命令查看所有的Java进程（同时也适用于Linux系统）</li><li>jstack <PID>  查看Java进程（PID）的所有线程（那一时刻的）情况（相当于快照）</li></ul><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326122426.png"></p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326122542.png">jconsole 来查看某个Java进程中线程的运行情况（图形界面）</p><h2 id="3-4-原理之线程运行"><a href="#3-4-原理之线程运行" class="headerlink" title="3.4 原理之线程运行"></a>3.4 原理之线程运行</h2><h4 id="3-4-1-栈与栈帧"><a href="#3-4-1-栈与栈帧" class="headerlink" title="3.4.1 栈与栈帧"></a>3.4.1 栈与栈帧</h4><p>JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机都会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧组成，对应着每次方法调用时候所占用的内存</li><li>每个线程只能有一个活动栈帧，对应正在执行的那一个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span> &#123;<br>    <span class="hljs-comment">//主方法的调用对应着主线程，（主线程启动之后）就会给它分配一块栈内存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method1(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> method2();<br>        System.out.println(m);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再创建一个线程，在<code>method1(20);</code>和<code>method1(10);</code>建立断点（以线程的方式添加断点），这段程序的主要就是要明白线程的栈内存是相互独立的，每个线程有自己独立的栈内存（里面有多个栈帧），它们之间互不干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                method1(<span class="hljs-number">20</span>);<br>            &#125;<br>        &#125;;<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        method1(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> method2();<br>        System.out.println(m);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-2-线程上下文切换（Thread-Context-Switch"><a href="#3-4-2-线程上下文切换（Thread-Context-Switch" class="headerlink" title="3.4.2 线程上下文切换（Thread Context Switch)"></a>3.4.2 线程上下文切换（Thread Context Switch)</h4><p>什么时候会发生线程上下文切换？当任务调度器将这些时间片都分配给每个线程运行的时候，每个线程的时间片用完的时候，用完了，就得把CPU的使用权交给其他线程，这时候当前线程就会发生线程上下文切换。也就是从使用CPU到了不使用CPU，这就称之为一次线程上下文切换。</p><p>发生的原因：</p><ul><li>线程的CPU时间片用光</li><li>垃圾回收（它会暂停当前所有的工作线程）</li><li>有更高的优先级的线程需要运行</li><li>线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法</li></ul><p>1、2、3都是被动的4是主动的。</p><p>当（Context Switch)发生的时候，需要由操作系统保存当前线程的状态（和Tmux的作用好像），并且恢复另一个线程的状态，Java中对应的概念就是程序计数器（Progmer Counter Register） ，它的作用是记住下一条JVM指令的地址，是线程私有的。</p><ul><li>状态包括程序计数器、虚拟机栈中每一个栈帧的信息，如局部变量、操作栈数、返回地址等。</li><li>Context Switch频繁发生会影响性能</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇六</title>
    <link href="/2024/04/09/str6/"/>
    <url>/2024/04/09/str6/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><p>解法一：</p><ul><li>我刚一见到这个题解的时候，脑子里蹦出了插入排序的那个代码，虽然只是一个简单题，但是这个题细节方面写的也是一个细节怪的写法，就是这句<code>i &lt;= n - m;</code>一懵还不理解，意思就是如果<code>n - m</code>个字符还没能匹配的上的话，那就没了呀 …… </li><li>整体的时间复杂度O((n - m)*m)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String ss, String pp)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ss.length(), n = pp.length();<br><span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//对于原串进行逐个遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m - n; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = i;<br><span class="hljs-comment">//匹配串遍历</span><br><span class="hljs-keyword">while</span> (a &lt; n &amp;&amp; ss.charAt(b) == pp.charAt(a))&#123;<br>a++;<br>b++;<br>&#125;<br><span class="hljs-keyword">if</span> (a == n) <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法二：</p><ul><li>KMP算法</li><li>时间复杂度O(m + n)</li></ul><p>这算法真奇怪一个简单的题目，使用这种算法感觉理解起来立马难度增加了一个档次，真的很难懂呀，先背过，以后再慢慢说吧</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240408174351.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String ss, String pp)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ss.length(), m = pp.length();<br>ss = <span class="hljs-string">&quot; &quot;</span> + ss;<br>pp = <span class="hljs-string">&quot; &quot;</span> + pp;<br><span class="hljs-comment">//要对于匹配串进行预处理</span><br><span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br><span class="hljs-type">char</span>[] s = ss.toCharArray(), p = pp.toCharArray();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++)&#123;<br><span class="hljs-comment">//如果两个字符不相等，就逐个向着下标为1（因为填补过&quot; &quot;）的位置移动</span><br><span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = next[j];<br><span class="hljs-comment">//如果两个字符相等，两个指针都向前移动</span><br><span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>next[i] = j;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = next[j];<br><span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>            <span class="hljs-comment">//这里的j和匹配串进行比较的返回的是第一个匹配的字符串的位置</span><br><span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> i - m;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/repeated-string-match/description/">686. 重复叠加字符串匹配 - 力扣（LeetCode）</a></p><p>方法一：暴力解决</p><ul><li>感觉暴力的解法还是比较容易去理解的，看了几遍基本上一下就能写出来的那一种。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">repeatedStringMatch</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a.length(), n = b.length();<br>        <span class="hljs-comment">//首尾各个添加一个</span><br>        <span class="hljs-keyword">if</span> (!check(a, b)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n / m + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">repeat</span> <span class="hljs-operator">=</span> a.repeat(i);<br>        <span class="hljs-keyword">if</span> (!repeat.contains(b)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">if</span> (!a.repeat(j).contains(b)) <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String a, String b)</span>&#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : a.toCharArray()) set.add(c);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : b.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span> (!set.contains(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">repeatedStringMatch</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (bs.length() &lt; b.length())&#123;<br>            ret++;<br>            bs.append(a);<br>        &#125;<br>        <span class="hljs-comment">//这里再加一次我的理解是为了防止bs的长度恰好和b的长度相等，但是又不能完全匹配</span><br>        bs.append(a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Strstr(bs.toString(), b);<br>        <span class="hljs-keyword">if</span> (idx == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> idx + b.length() &lt;= a.length()*ret ? ret : ret + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">Strstr</span><span class="hljs-params">(String ss, String pp)</span>&#123;<br>        <span class="hljs-keyword">if</span> (pp.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ss.length(), n = pp.length();<br>        <span class="hljs-comment">//对于匹配串进行预处理</span><br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//这里一定是&quot; &quot; + ss(空字符串+字符串)</span><br>        ss = <span class="hljs-string">&quot; &quot;</span> + ss;<br>        pp = <span class="hljs-string">&quot; &quot;</span> + pp;<br>        <span class="hljs-comment">//ss:String原串  p : pattern匹配串</span><br>        <span class="hljs-type">char</span>[] s = ss.toCharArray(), p = pp.toCharArray();<br>        <span class="hljs-comment">//i从2开始，因为kmp的next数组的构造都是从1开始的，而下标1（即p[0]）没有前缀，next[1] = 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">//如果两个指针所指向的字符不同，j就一直向前移动，一直移动到下标为1（就是第一个字符）的位置</span><br>            <span class="hljs-comment">//这里j = next[j]我对于这个东西的理解是next[j]实际上就相当于j下标的前一位</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = next[j];<br>            <span class="hljs-comment">//如果两个字符相等，两个指针一块移动</span><br>            <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = next[j];<br>            <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>            <span class="hljs-keyword">if</span> (j == n) <span class="hljs-keyword">return</span> i - n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：时间复杂度极高的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">repeatedStringMatch</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (bs.length() &lt; b.length())&#123;<br>            bs.append(a);<br>            ret++;<br>        &#125;<br>        <span class="hljs-comment">//想要完全匹配，至少bs的长度得大于b的长度，等于都不行</span><br>        bs.append(a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> strStr(bs.toString(), b);<br>        <span class="hljs-keyword">if</span> (idx == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//因为bs在最后多加了一次，所以不能使用bs</span><br><span class="hljs-comment">//        return idx + b.length() &lt; bs.length() ? ret : ret + 1;</span><br>        <span class="hljs-keyword">return</span> idx + b.length() &lt;= a.length()*ret ? ret : ret + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String ss, String pp)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ss.length(), n = pp.length();<br>        <span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//对于原串进行逐个遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m - n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = i;<br>            <span class="hljs-comment">//匹配串遍历</span><br>            <span class="hljs-keyword">while</span> (a &lt; n &amp;&amp; ss.charAt(b) == pp.charAt(a))&#123;<br>                a++;<br>                b++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (a == n) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s + s;<br>        <span class="hljs-comment">//破坏首和尾</span><br>        <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">1</span>, str.length() - <span class="hljs-number">1</span>).contains(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shortest-palindrome/description/">214. 最短回文串 - 力扣（LeetCode）</a></p><ul><li><code>s.substring(a, b)</code>两个参数（左闭右开）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br><span class="hljs-keyword">var</span> res=str.substring(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);<br> console.log(res);<br>结果res为：<span class="hljs-string">&quot;cdef&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>s.substring(a)</code>一个参数（闭区间）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br><span class="hljs-keyword">var</span> res=str.substring(<span class="hljs-number">3</span>);<br>console.log(res);<br>结果res为：<span class="hljs-string">&quot;defghijklmn&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">shortestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-type">var</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br><span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.toCharArray();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-comment">//这里的j &gt; 0，是因为next数组的构建是从1开始的</span><br><span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; c[i] != c[j + <span class="hljs-number">1</span>]) j = next[j];<br><span class="hljs-keyword">if</span> (c[i] == c[j + <span class="hljs-number">1</span>]) j++;<br>next[i] = j;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//从0到n是因为s = &quot; &quot; + s，这里的逆序串相当于原串，正序串相当于匹配串，它的极限就是一个正序加上一个逆序刚好凑成一个回文串</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span> &amp;&amp; c[len + <span class="hljs-number">1</span>] != c[i]) len = next[len];<br><span class="hljs-keyword">if</span> (c[len + <span class="hljs-number">1</span>] == c[i]) len++;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (len == n ? <span class="hljs-string">&quot;&quot;</span> : s.substring(len + <span class="hljs-number">1</span>));<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(x).reverse();<br>res.append(s.substring(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">return</span> res.toString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串变换"><a href="#字符串变换" class="headerlink" title="字符串变换"></a>字符串变换</h1><p><a href="https://leetcode.cn/problems/license-key-formatting/description/">482. 密钥格式化 - 力扣（LeetCode）</a></p><p>这个题目对于某些细节方面的处理实在是我没有想得到的，还有就是<code>ans.deleteCharAt(ans.length() - 1);</code>这一句我没有想过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">licenseKeyFormatting</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br><span class="hljs-keyword">if</span> (s.charAt(i) != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>count++;<br>ret.append(Character.toUpperCase(s.charAt(i)));<br><span class="hljs-keyword">if</span> (count % k == <span class="hljs-number">0</span>) ret.append(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (ret.length() &gt; <span class="hljs-number">0</span> &amp;&amp; ret.charAt(ret.length() - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;-&#x27;</span>) ret.deleteCharAt(ret.length() - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> ret.reverse().toString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/zigzag-conversion/">6. Z 字形变换 - 力扣（LeetCode）</a></p><p>方法一：</p><p>这种方法确实写起来很简单，但是真的很难去想的到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span> || numRows &gt;= n) <span class="hljs-keyword">return</span> s;<br>        List&lt;StringBuilder&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, flag = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            lists.get(i).append(c);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == numRows - <span class="hljs-number">1</span>) flag *= -<span class="hljs-number">1</span>;<br>            i += flag;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; a &lt; lists.size(); a++) bs.append(lists.get(a));<br>        <span class="hljs-keyword">return</span> bs.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：模拟</p><p>构造一个x行y列的一个二维字符数组，将S中的字符逐个添加到字符数组中去，这个二维数组的行数就是numRows的值，二维数组的列数需要通过它的周期性变化进行计算</p><ul><li>通过numRows可以计算得出<strong>一整个周期的字符数</strong>还有<strong>一整个周期的列数</strong></li><li>一个周期有多少个字符？      t &#x3D;  numRows + numRows - 2个字符</li><li>一个周期有多少列？             1 + numRows - 2列也就是  numRows - 1列</li><li>通过字符串总字符的个数以及一个周期字符数可以得出有多少个周期（上取整）总周期数为(n + t - 1)&#x2F;t</li></ul><p>通过总的周期数乘上每个周期的列数得出了二维数组的总列数</p><ul><li>所以得出这个字符需要总的列数为：[(n + t - 1)&#x2F;t ] *(numRows - 1)</li></ul><p>上取整操作还是有一些技巧在里面的就比如a&#x2F;b进行上取整操作就是(a + b - 1)&#x2F;b因为a &#x2F; b加的这个值肯定是小于1的（通过分子给足了b的面子，你最多就是加上一个1假如就取得一个极限值a &#x3D; 1那么就是1&#x2F;b进行上取整）这么理解真的通了</p><p>上述步奏都想通了昨天做的时候，字符周期性变化没有想通（看了答案想通了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span> || numRows &gt; n) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> numRows*<span class="hljs-number">2</span> - <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (n + t - <span class="hljs-number">1</span>)/t *(numRows - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span>[][] v  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[numRows][c];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            v[x][y] = s.charAt(i);<br>            <span class="hljs-keyword">if</span>(i % t &lt; numRows - <span class="hljs-number">1</span>) x++;<br>            <span class="hljs-keyword">else</span>&#123;<br>                x--;<br>                y++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>[] d : v)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> k : d)&#123;<br>                <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span>) bs.append(k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bs.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>tips总的来说这几天的这个子序列真的让我受益匪浅，真的感觉了解了许多，前几天的那两个动态规划，这两天的KMP这几个这几天真的弄得我很难理解但是我都硬啃下来了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇五</title>
    <link href="/2024/03/31/str5/"/>
    <url>/2024/03/31/str5/</url>
    
    <content type="html"><![CDATA[<h1 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h1><p><a href="https://leetcode.cn/problems/is-subsequence/description/">392. 判断子序列 - 力扣（LeetCode）</a></p><p>方法一：自己想的用的非常辣鸡的栈的方法（shi）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Stack&lt;Character&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Stack&lt;Character&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c1 : s.toCharArray()) stack1.push(c1);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c2 : t.toCharArray()) stack2.push(c2);<br>        <span class="hljs-keyword">while</span> (!stack2.isEmpty() &amp;&amp; !stack1.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (stack2.peek() == stack1.peek()) &#123;<br>                stack1.pop();<br>            &#125;<br>            stack2.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：双指针</p><p>给人的感觉就是这个方法跟上面我想的差不了多少，但是呢，我没有想到i &#x3D;&#x3D; n这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), m = t.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：动态规划</p><p>这个方法真是顶级</p><p>最后，是将26列均置为m而不是简单地把m列均置为m，因为这个今天已经错了好多次了</p><ul><li><code>f[i][j]</code>表示从字符i位置开始向后<code>f[i][j]</code>个位置字符j第一次出现的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String dictiobary)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), m = dictiobary.length();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">//第m + 1行全部填上了m长度，其实m + 1行填上m就相当于最后一行是无穷大</span><br>        Arrays.fill(f[m], m);<br>        <span class="hljs-comment">//for (int i = 0; i &lt; 26; i++) f[m][i] = m;</span><br>        <span class="hljs-comment">//将字典中的各个位置的字符字符记住</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dictiobary.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span> == j) f[i][j] = i;<br>                <span class="hljs-keyword">else</span> f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (f[add][s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//这一句是没有else的，还有add = f[add][s.charAt(i) - &#x27;a&#x27;] + 1;</span><br>            add = f[add][s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String dictionary)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = dictionary.length();<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == dictionary.charAt(j - <span class="hljs-number">1</span>)) f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (f[i][j] == m) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/description/">524. 通过删除字母匹配到字典里最长单词 - 力扣（LeetCode）</a></p><p>方法一：双指针</p><p>刚开始看到答案的时候理解不了<code>t.compareTo(res) &lt; 0</code>这一句到底是干什么的</p><ul><li>经过一节课的沉淀之后理解了<code>(t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; 0</code>当字典中的两个单词长度一致时候，<code>t.compareTo(res)</code>可以比较二者的字典序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (String t : dictionary) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; t.length() &amp;&amp; j &lt; s.length()) &#123;<br>                <span class="hljs-keyword">if</span> (t.charAt(i) == s.charAt(j)) ++i;<br>                ++j;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == t.length()) &#123;<br>                <span class="hljs-comment">//这里其实可以将t.length()换成i，效率会更高一些</span><br>                <span class="hljs-keyword">if</span> (t.length() &gt; res.length() || (t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; <span class="hljs-number">0</span>)) &#123;<br>                    res = t;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：排序（方法一的基础）</p><p>有一说一，这Lambda表达式真难写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; dictionary)</span> &#123;<br>        Collections.sort(dictionary,(a, b) -&gt;&#123;<br>            <span class="hljs-comment">//如果长度不同，按照长度从大到小进行排序</span><br>            <span class="hljs-keyword">if</span> (a.length() != b.length()) <span class="hljs-keyword">return</span> b.length() - a.length();<br>            <span class="hljs-comment">//如果长度相同，按照字典序进行排序</span><br>            <span class="hljs-keyword">return</span> a.compareTo(b);<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (String ss : dictionary)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ss.length();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)&#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == ss.charAt(j)) j++;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> ss;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开来写就是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(dictionary, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o1.length() != o2.length()) <span class="hljs-keyword">return</span> o2.length() - o1.length();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>方法三：动态规划写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-comment">// 动态规划写法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>            f[m][i] = m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span> == j)<br>                    f[i][j] = i;<br>                <span class="hljs-keyword">else</span><br>                    f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (String ss : dictionary) &#123;<br>            <span class="hljs-comment">//一定要将这个写在循环体内部</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> ss.length();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-keyword">if</span> (f[add][ss.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == m) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                add = f[add][ss.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-keyword">if</span> (ret.length() &lt; ss.length() || (ret.length() == ss.length() &amp;&amp; ss.compareTo(ret) &lt; <span class="hljs-number">0</span>)) &#123;<br>                    ret = ss;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii/description/">522. 最长特殊序列 II - 力扣（LeetCode）</a></p><p>方法一：枚举法</p><p>我陷入了一个误区，就是这个<code>is_Match</code>函数的这两个参数，它的次序很重要，在<code>findLUSlength</code>的第二个<code>for</code>循环中，如果两个不同的字符串后面有一个字符串完全可以匹配当前（strs[i]字符串）字符串，就可以完全跳过当前（strs[i]字符串）去寻找下一个目标了，因为我你<code>strs[i]</code>字符串所拥有的字符我<code>strs[j]</code>全部都具有，<code>strs[j]</code>位置靠后，具有一定的绝对主动权(感觉这个应该也算是一种贪心吧)。（理解到位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//枚举每一个字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLUSlength</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; is_Match(strs[i], strs[j]))&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag)&#123;<br>                ret = Math.max(ret, strs[i].length());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">is_Match</span><span class="hljs-params">(String s, String dictionary)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = dictionary.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n)&#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == dictionary.charAt(j)) i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == s.length();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：DP </p><p>这里需要最长公共子序列的DP基础，没学过，呜呜呜~~~，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLUSlength</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; check(strs[i], strs[j]))&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) ans = Math.max(ans, strs[i].length());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s, String d)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s.length(), len2 = d.length();<br>        <span class="hljs-comment">//如果我前面s的长度大于后面d的长度压根就不是你的子序列</span><br>        <span class="hljs-keyword">if</span> (len1 &gt; len2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == d.charAt(j - <span class="hljs-number">1</span>)) f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (f[i][j] == len1) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-common-subsequence/solutions/696763/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p><p>定义<code>f[i][j]</code>表示：<code>s1[0 : i]</code> 和<code>s2[0 : j]</code>的最长公共子序列的长度</p><ul><li>上述表示种，<code>s1[0 : i]</code>表示s1长度为i的前缀，<code>s2[0 : j]</code>表示s2长度为j的前缀，</li></ul><p>考虑动态规划的边界情况：</p><ul><li>当 i &#x3D; 0时候，<code>s1[0 : i]</code>为空，空字符串和任何字符串的最长公共子序列长度均为0，因此对于任意0 &lt;&#x3D; j &lt;&#x3D; m ，都有<code>f[0][j] = 0</code></li><li>当 j &#x3D; 0时候，<code>s2[0 : j]</code>为空，空字符串和任何字符串的最长公共子序列长度均为0，因此对于任意0 &lt;&#x3D; i &lt;&#x3D; m ，都有<code>f[i][0] = 0</code></li></ul><p>因此动态规划的边界情况是：当i或者j等于0的时候<code>f[i][j] = 0</code>。</p><p>当 i &gt; 0 且 j &gt; 0 的时候，，考虑<code>f[i][j]</code>的计算：</p><ul><li>当<code>s1[i - 1] = s2[j - 1]</code>时，将这两个相同的字符串称为公共字符，考虑 <code>s1[0 : i - 1] </code>和 <code>s2[0 : j - 1]</code> 的最长公共子序列，再增加一个字符（公共字符）即可得到<code>s1[0 : i] </code>和<code>s2[0 : j]</code>的最长公共子序列因此 <code>f[i][j] = f[i - 1][j - 1] + 1</code></li><li>当<code>s1[i - 1] != s2[j - 1]</code>时，考虑<code>s1[0 : i]</code> 和 <code>s2[0 : j - 1]</code> 的最长公共子序列和<code>s1[0 : i - 1]</code> 和 <code>s2[0 : j]</code> 的最长公共子序列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s1.length(), n = s2.length();<br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s1.charAt(i - <span class="hljs-number">1</span>) == s2.charAt(j - <span class="hljs-number">1</span>)) f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> f[i][j] = Math.max(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组篇四</title>
    <link href="/2024/03/31/arr4/"/>
    <url>/2024/03/31/arr4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间 - 力扣（LeetCode）</a></p><p><code>List.toArray()</code>方法，将集合转化为数组</p><p><code>Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);</code>将二维数组按照第一列的大小进行排序</p><p>方法一：将二维数组按照第一列的大小进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] interval: intervals)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> interval[<span class="hljs-number">0</span>], b = interval[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//如果ans为空 或者 （ans不为空）右边界小于新区间的左边界，则要添加新的区间</span><br>            <span class="hljs-keyword">if</span>(ans.isEmpty() || ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; a)&#123;<br>                ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a, b&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//不为空且要合成新的区间，比较右边边界</span><br>                ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(ans.get(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], b);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：将二维数组按照第二列的大小进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        ArrayList&lt;<span class="hljs-type">int</span>[]&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">0</span>], R = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(ret.isEmpty() || R &lt; ret.get(ret.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])&#123;<br>                ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;L, R&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ret.get(ret.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] = Math.min(ret.get(ret.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>], L);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ret.size()][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/submissions/518258385/?envType=daily-question&envId=2024-03-27">2580. 统计将重叠区间合并成组的方案数 - 力扣（LeetCode）</a></p><p>方法一：将二维数组按照第一列的大小进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges)</span> &#123;<br>        Arrays.sort(ranges, (a, b) -&gt; a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ranges.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxR</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ranges[i][<span class="hljs-number">0</span>], b = ranges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(maxR &lt; a) &#123;<br>                ans = ans*<span class="hljs-number">2</span>;<br>                ans %= <span class="hljs-number">1000000007</span>;<br>            &#125;<br>            maxR = Math.max(b, maxR);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：将二维数组按照第二列的大小进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges)</span> &#123;<br>        Arrays.sort(ranges,(a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//使用第二位数字进行排序时候，就要逆序遍历了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minL</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ranges.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> ranges[i][<span class="hljs-number">0</span>], R = ranges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(minL &gt; R)&#123;<br>                ans = ans*<span class="hljs-number">2</span>;<br>                ans %= <span class="hljs-number">1000000007</span>;<br>            &#125;<br>            minL = Math.min(minL, L);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <a href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/?envType=daily-question&envId=2024-03-30">2952. 需要添加的硬币的最小数量 - 力扣（LeetCode）</a></p><p>此题目对于思维能力感觉要求就是很高的那种，虽然它的代码及其简短（甚至都可以背得下来），但是代码是背不完的（除了排序），还是要对于代码具有一定的理解</p><ul><li><p>对于一个整数<code>x</code>，如果区间<code>[1, x - 1]</code>内的所有金额都可以取的到，而且<code>x</code>还在数组之中，则区间<code>[1, 2x - 1]</code>内的所有金额也都可以取的到。</p></li><li><p>假设金额<code>x</code>不可取的，则至少要在数组中添加一个小于或者等于<code>x</code>的数组才能取得<code>x</code>，否则，无法取得<code>x</code>。</p></li><li><p>如果区间<code>[1, x - 1]</code>内的所有金额都可以取的到，则从贪心的角度来看，添加<code>x</code>之后则可以取得<code>x</code>，且满足添加的金额个数最少。在添加了<code>x</code>之后，区间 <code>[1, 2x - 1]</code>的所有金额都可以取的到，下一个不可取得的金额一定不会小于<code>2x</code>。</p></li><li><p>由此可以得到一个贪心的方案。每次找到不可取得的最小金额<code>x</code>，在数组之中添加<code>x</code>，之后，然后寻找下一个不可取得的最小整数，重复上述步骤，直到区间<code>[1, target]</code>中的所有金额都可以取得。</p><p>具体实现方面，任何时候都应满足区间 <code>[1,x−1]</code> 内的所有金额都可取得。令 <code>x</code> 的初始值为 1，数组下标 <code>index</code> 的初始值为 0，则初始状态下区间 <code>[1,x−1] </code>为空区间，满足区间内的所有金额都可取得。进行如下操作。</p><ul><li>如果<code> index</code> 在数组 <code>coins</code> 的下标范围内且 <code>coins[index]≤x</code>，则将 <code>coins[index]</code> 的值加给 x，并将 <code>index</code>的值加 1。可取得的区间从<code>[1,x−1] </code>扩展到 <code>[1,x+coins[index]−1]</code>，对 x 的值更新以后，可取得区间为 <code>[1,x−1]</code>。</li><li>否则，<code>x</code>没有可取得，因此需要在数组中添加<code>x</code>，然后将 x 的值乘以2。</li><li>在数组中添加 <code>x</code>之后，可取得的区间从<code>[1,x−1]</code>扩展到<code>[1,2x−1]</code>，对 x的值更新以后，可取得区间为<code>[1,x−1]</code>。</li><li>重复上述操作，直到<code>x</code>的值大于 <code>target</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumAddedCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length,x = <span class="hljs-number">1</span>,index = <span class="hljs-number">0</span>,ans = <span class="hljs-number">0</span>;<br>        Arrays.sort(coins);<br>        <span class="hljs-keyword">while</span>(x &lt;= target)&#123;<br>            <span class="hljs-keyword">if</span>(index &lt; n &amp;&amp; coins[index] &lt;= x)&#123;<br>                x += coins[index];<br>                index++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                x *= <span class="hljs-number">2</span>;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-original-array-from-doubled-array/?envType=daily-question&envId=2024-04-18">2007. 从双倍数组中还原原数组 - 力扣（LeetCode）</a></p><p>自己写的，之前从来没有注意过时间复杂度这个概念，然后毫无以外的超时了</p><ul><li><code>1 &lt;= changed.length &lt;= 10^5</code></li><li><code>0 &lt;= changed[i] &lt;= 10^5</code></li></ul><p>力扣上的题目的时间限制是1秒或2秒</p><p>n≤30, 指数级别, dfs+剪枝，状态压缩dp<br>n≤100 &#x3D;&gt; O(n3)，floyd，dp<br>n≤1000 &#x3D;&gt; O(n2)，O(n2logn)，dp，二分<br>分界点（一旦n到达1e4，就不适合n2的暴力解法）<br>n≤10000 &#x3D;&gt; O(n∗√n)，块状链表<br>n≤100000 &#x3D;&gt; O(nlogn) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、dijkstra+heap、spfa、求凸包、求半平面交、二分<br>n≤1000000 &#x3D;&gt; O(n), 以及常数较小的 O(nlogn) 算法 &#x3D;&gt; hash、双指针扫描、kmp、AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa<br>n≤10000000 &#x3D;&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数<br>n≤10^9 &#x3D;&gt; O(√n)，判断质数<br>n≤10^18 &#x3D;&gt; O(logn)，最大公约数</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/6d050dd55590495ad7a4d28848d59a98.png" style="zoom:50%;" /><p>很显然这个题目不能使用0（n^2）的时间复杂度来计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOriginalArray(<span class="hljs-type">int</span>[] changed) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> changed.length;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n / <span class="hljs-number">2</span>];<br>        Arrays.sort(changed);<br>        <span class="hljs-type">boolean</span>[] tag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (tag[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (t &lt;= n) &#123;<br>                <span class="hljs-keyword">if</span> (t == i)&#123;<br>                    t++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (t == n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>                <span class="hljs-keyword">if</span> (!tag[t] &amp;&amp; changed[t]*<span class="hljs-number">2</span> == changed[i]) &#123;<br>                    tag[t] = <span class="hljs-literal">true</span>;<br>                    res[idx++] = changed[t];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                t++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种解法：排序+哈希</p><p>时间复杂度（O(nlogn)）</p><p>排序的时间复杂度（O(nlogn)）    遍历数组的时间复杂度 O(n)</p><p>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOriginalArray(<span class="hljs-type">int</span>[] arr) &#123;<br>        Arrays.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n/<span class="hljs-number">2</span>];<br>        HashMap&lt;Integer, Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e : arr) counts.put(e, counts.getOrDefault(e, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e : arr)&#123;<br>            <span class="hljs-keyword">if</span>(counts.get(e) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            counts.put(e, counts.get(e)-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(counts.getOrDefault(<span class="hljs-number">2</span>*e, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>            counts.put(<span class="hljs-number">2</span>*e, counts.getOrDefault(e*<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>            res[idx++] = e;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2024/03/28/tree1/"/>
    <url>/2024/03/28/tree1/</url>
    
    <content type="html"><![CDATA[<p>主要是对于递归的理解没有很透彻</p><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>二叉搜索树（Binary Search Tree, BST）是一种很常见的二叉树。它的定义是： 一个二叉树中任意节点的值要大于等于所有左子树节点的值，且要小于等于右边子树所有节点的值</p><p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> ^ q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p.val != q.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> isSameTree(q.left, p.left) &amp;&amp;<br>                   isSameTree(q.right, p.right); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：</p><p>广度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Queue&lt;TreeNode&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        Queue&lt;TreeNode&gt; queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        queue1.offer(p);<br>        queue2.offer(q);<br>        <span class="hljs-keyword">while</span>(!queue1.isEmpty() &amp;&amp; !queue2.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> queue2.poll();<br>            <span class="hljs-keyword">if</span>(node1.val != node2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left1</span> <span class="hljs-operator">=</span> node1.left, right1 = node1.right,left2 = node2.left, right2 = node2.right;<br>            <span class="hljs-keyword">if</span>(left1 == <span class="hljs-literal">null</span> ^ left2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(right1 == <span class="hljs-literal">null</span> ^ right2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(left1 != <span class="hljs-literal">null</span>) queue1.offer(left1);<br>            <span class="hljs-keyword">if</span>(right1 != <span class="hljs-literal">null</span>) queue1.offer(right1);<br>            <span class="hljs-keyword">if</span>(left2 != <span class="hljs-literal">null</span>) queue2.offer(left2);<br>            <span class="hljs-keyword">if</span>(right2 != <span class="hljs-literal">null</span>) queue2.offer(right2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判定是否一个二叉树中任意节点的值要大于等于所有左子树节点的值，且小于等于右边子树所有节点的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(Node root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.l != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= root.l.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.r != <span class="hljs-literal">null</span> &amp;&amp; root.val &gt;= root.r.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> isValidBST(root.l) &amp;&amp; isValidBST(root.r);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个算法出现了一定的错误，BST的每一个节点应该要小于右边子数的所有节点，下面这个二叉树显然不是BST，但是上述算法会将其判定为BST</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240326182119.png" style="zoom: 50%;" /><p>重新看一下BST的定义，Root做的并不只是和左右节点的比较，而是需要和整个左子树和右子树的所有节点进行比较。这种情况下我们可以使用辅助函数，增加函数参数列表。在参数中携带额外信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid_BST</span><span class="hljs-params">(Node root, Node min, Node max)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (min != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(max != <span class="hljs-literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> isValid_BST(root.left, min, root) &amp;&amp; isValid_BST(root.right, root, max);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/submissions/517714155/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><p>根据二叉树的性质，在递归调用左子树时候，将上界改为root</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> judge(root, Long.MAX_VALUE, Long.MIN_VALUE);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> max, <span class="hljs-type">long</span> min)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//这里是或</span><br>        <span class="hljs-keyword">if</span>(root.val &gt;= max || root.val &lt;= min) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//判断左边，将上界修改为root.val                  判断右边将下界改为root.val</span><br>        <span class="hljs-keyword">return</span> judge(root.left, root.val, min) &amp;&amp; judge(root.right, max, root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一：在BST中查找一个数字是否存在"><a href="#一：在BST中查找一个数字是否存在" class="headerlink" title="一：在BST中查找一个数字是否存在"></a>一：在BST中查找一个数字是否存在</h2><p>根据我们的指导思想，我们可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(root.val == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> isInBST(root.left, target)|| isInBST(root.right, target);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写完全正确但是如何将BST“左小右大”的特性运用上？</p><p>很简单，其实不需要这样递归的左右两边搜索，类似于二分查找的思想，根据target和root.val的大小进行比较，就能排除一边。我们将上面的思路稍稍改动一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isInBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(root.val == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root.val &lt; target) <span class="hljs-keyword">return</span> isInBST(root.right, target);<br>    <span class="hljs-keyword">if</span>(root.val &gt; target) <span class="hljs-keyword">return</span> isInBST(root.left, target);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/517709057/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> tar)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root.val == tar) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> root.val &gt; tar? searchBST(root.left, tar) : searchBST(root.right, tar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、在BST中插入一个数字"><a href="#二、在BST中插入一个数字" class="headerlink" title="二、在BST中插入一个数字"></a>二、在BST中插入一个数字</h2><p>对于数据结构的操作无非是<code>遍历</code>+<code>访问</code>，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数字，就是先找到插入位置，然后进行插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-comment">//找到空位置，插入节点</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>    <span class="hljs-comment">// if(root.val == val) </span><br>    <span class="hljs-comment">// BST中一般不会插入已存在的元素</span><br>    <span class="hljs-keyword">if</span>(root.val &lt; val) root.right = insertIntoBST(root.right, val);<br>    <span class="hljs-keyword">if</span>(root.val &gt; val) root.left = insertIntoBST(root.left, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; val) root.right = insertIntoBST(root.right,val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; val) root.left = insertIntoBST(root.left,val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、在BST中删除一个数字"><a href="#三、在BST中删除一个数字" class="headerlink" title="三、在BST中删除一个数字"></a>三、在BST中删除一个数字</h2><p>这个问题有一点复杂，跟插入的操作优点类似，先找然后再改。先将框架写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>        <span class="hljs-comment">//找到了，进行删除操作</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<br>        root.left = deleteNode(root.left, key);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<br>        root.right = deleteNode(root.right, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到了这个节点，比方说是节点A，如何将这个节点进行删除，这是难点。因为删除节点的同时不能破环BST的性质。有三种情况，这里使用图片进行说明。</p><p>情况一：恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240328154229.png" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>情况二：A只有一个孩子节点，那么就让它的孩子节点接他的班</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240328154452.png" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//排除了情况一之后</span><br><span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br><span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br></code></pre></td></tr></table></figure><p>情况三：A具有两个子节点，为了不破环BST的性质，A必须找到左子树中最大的那一个节点或者右子树中最小的那一个节点来接替自己。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240328154909.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-comment">//找到右子树的最小节点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> getMin(root.right);<br>    <span class="hljs-comment">//将root改成minNode</span><br>    root.val = minNode.val;<br>    <span class="hljs-comment">//转而删除minNode</span><br>    root.right = delete(root.right, minNode.val);<br>&#125;<br></code></pre></td></tr></table></figure><p>三种情况分析完毕，填入框架，简化一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(root.val == key) &#123;<br>        <span class="hljs-comment">//将情况一和情况二均处理了</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br>    <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br>        <span class="hljs-comment">//处理情况三</span><br>    <span class="hljs-comment">//找到右子树的最小节点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> getMin(root.right);<br>    <span class="hljs-comment">//将root改成minNode</span><br>    root.val = minNode.val;<br>    <span class="hljs-comment">//转而删除minNode</span><br>    root.right = deleteNode(root.right, minNode.val);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<br>        root.left = deleteNode(root.left, key);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<br>        root.right = deleteNode(root.right, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br>TreeNode <span class="hljs-title function_">getMin</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-comment">//BST的最左边就是最小的</span><br>    <span class="hljs-keyword">while</span>(node.left != <span class="hljs-literal">null</span>) node = node.left;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/submissions/517689274/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br>            <span class="hljs-comment">//可以理解为这层循环递归调用root返回root.left就相当于删除了left</span><br>            <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">min_Node</span> <span class="hljs-operator">=</span> getMin(root.right);<br>                root.val = min_Node.val;<br>                <span class="hljs-comment">//递归调用删除min_Node</span><br>                root.right = deleteNode(root.right, min_Node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getMin</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 一个二叉搜索树中的最小值就是最左边的那一个</span><br>        <span class="hljs-keyword">while</span> (root.left != <span class="hljs-literal">null</span>)<br>            root = root.left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java新特性</title>
    <link href="/2024/03/24/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/03/24/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>下辈子一定好好学习</p><h1 id="Lambda表达式的使用"><a href="#Lambda表达式的使用" class="headerlink" title="Lambda表达式的使用"></a>Lambda表达式的使用</h1><ol><li><p>举例：<code>(o1, o2) -&gt; Integer.compare(o1, o2)</code>;</p></li><li><p>格式：</p><p>​        -&gt;Lambda操作符或者箭头操作符</p><p>​        -&gt;Lambda的形参列表（其实就是接口中抽象方法的形参列表）</p><p>​        -&gt;Lambda体（就是重写抽象方法的方法体）</p></li><li><p>Lambda表达式的使用（6种情况）</p></li><li><p>Lambda表达式的本质：作为接口的实例</p></li></ol><h2 id="语法格式一："><a href="#语法格式一：" class="headerlink" title="语法格式一："></a>语法格式一：</h2><p>无参、无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr1</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我爱我家！&quot;</span>);<br>            &#125;<br>        &#125;;<br>        r1.run();<br><br>        System.out.println(<span class="hljs-string">&quot;**********************************************&quot;</span>);<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> ()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;当然，我也爱我家呀！&quot;</span>);<br>        &#125;;<br>        r2.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法格式二："><a href="#语法格式二：" class="headerlink" title="语法格式二："></a>语法格式二：</h2><p>Lambda表达式需要一个参数但是没有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr2</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>        Consumer&lt;String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>                System.out.println(s);<br>            &#125;<br>        &#125;;<br>        consumer.accept(<span class="hljs-string">&quot;你能听懂我所说的话吗？&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;**********************************************&quot;</span>);<br><br>        Consumer&lt;String&gt; consumer1 = (String s)-&gt; &#123;<br>            System.out.println(s);<br>        &#125;;<br>        consumer1.accept(<span class="hljs-string">&quot;是的呀，我可以听得懂。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法格式三："><a href="#语法格式三：" class="headerlink" title="语法格式三："></a>语法格式三：</h2><p>数据类型可以省略，因为可以由编译器推断得出，称为类型推断。</p><p>这个让我想起了**<code>var i = 0</code><strong>还有</strong><code>int[] arr = new int[]&#123;3,1,5,9,7&#125;</code>**这个应该也是类型推断吧！！！（算了，就这么记）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr3</span> &#123;<br>    <span class="hljs-comment">//类型推断</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test03</span><span class="hljs-params">()</span>&#123;<br>        Consumer&lt;String&gt; consumer = (String s) -&gt; &#123;<br>            System.out.println(s);<br>        &#125;;<br>        consumer.accept(<span class="hljs-string">&quot;A:欲买桂花同载酒下一句是什么？&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;*******************************************&quot;</span>);<br><br>        Consumer&lt;String&gt; con = (s)-&gt; &#123;<br>            System.out.println(s);<br>        &#125;;<br>        con.accept(<span class="hljs-string">&quot;B:它的下一句是“终不似，少年游&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法格式四："><a href="#语法格式四：" class="headerlink" title="语法格式四："></a>语法格式四：</h2><p>Lambda只需要一个一个参数的话，参数的那一个小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr4</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test04</span><span class="hljs-params">()</span>&#123;<br>        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;<br>            System.out.println(s);<br>        &#125;;<br>        con1.accept(<span class="hljs-string">&quot;人生若只如初见&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;*******************************&quot;</span>);<br><br>        Consumer&lt;String&gt; con2 = s -&gt; &#123;<br>            System.out.println(s);<br>        &#125;;<br>        con2.accept(<span class="hljs-string">&quot;何事秋风悲画扇&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法格式五："><a href="#语法格式五：" class="headerlink" title="语法格式五："></a>语法格式五：</h2><p>Lambda表达式需要两个或者以上的参数时候，执行多条语句，并且可以有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr5</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test05</span><span class="hljs-params">()</span>&#123;<br>        Comparator&lt;Integer&gt; com1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer A, Integer B)</span> &#123;<br>                System.out.println(A);<br>                System.out.println(B);<br>                <span class="hljs-keyword">return</span> A.compareTo(B);<br>            &#125;<br>        &#125;;<br>        System.out.println(com1.compare(<span class="hljs-number">21</span>,<span class="hljs-number">12</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;****************************************&quot;</span>);<br><br>        Comparator&lt;Integer&gt; com2 = (A,B)-&gt; &#123;<br>                System.out.println(A);<br>                System.out.println(B);<br>                <span class="hljs-keyword">return</span> A.compareTo(B);<br>            &#125;;<br>        System.out.println(com2.compare(<span class="hljs-number">1</span>,<span class="hljs-number">12</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法格式六："><a href="#语法格式六：" class="headerlink" title="语法格式六："></a>语法格式六：</h2><p>当Lambda体只有一条语句的时候，return与大括号若有，则都可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr6</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test06</span><span class="hljs-params">()</span>&#123;<br>        Comparator&lt;Integer&gt; con1= (A,B)-&gt;&#123;<br>            <span class="hljs-keyword">return</span> A.compareTo(B);<br>        &#125;;<br>        System.out.println(con1.compare(<span class="hljs-number">21</span>,<span class="hljs-number">11</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;****************************&quot;</span>);<br><br>        Comparator&lt;Integer&gt; con2= (A,B)-&gt; A.compareTo(B);<br>        System.out.println(con2.compare(<span class="hljs-number">21</span>,<span class="hljs-number">11</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;****************************&quot;</span>);<br><br>        Comparator&lt;Integer&gt; con3= Integer::compareTo;<br>        System.out.println(con3.compare(<span class="hljs-number">21</span>,<span class="hljs-number">31</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>compare是compator接口中的一个方法用于比较两个对象</p><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/submissions/514685249/">451. 根据字符出现频率排序 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pr3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>().frequencySort1(<span class="hljs-string">&quot;tree&quot;</span>));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">frequencySort1</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) map.put(c , map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        List&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.keySet());<br><br>        list.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Character&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Character a, Character b)</span> &#123;<br>                <span class="hljs-keyword">return</span> map.get(b) - map.get(a);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//就相当于这一句</span><br><span class="hljs-comment">//        list.sort((a , b) -&gt; map.get(b) - map.get(a));</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> map.get(c);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                bs.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bs.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个Java程序，其中使用了Lambda表达式。让我们逐步解释这段代码中Lambda表达式的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">list.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Character&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Character a, Character b)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.get(b) - map.get(a);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这段代码中的Lambda表达式是用来创建一个比较器（Comparator）。Comparator是一个函数式接口，它定义了一个用于比较两个对象的方法。在这里，我们想要对列表中的字符按照它们在map中对应的值的降序进行排序。</p><p>Lambda表达式的部分是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(Character a, Character b) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> map.get(b) - map.get(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们逐步解释Lambda表达式的各个部分：</p><ol><li><p><code>(Character a, Character b)</code>：这部分声明了Lambda表达式的参数列表。在这里，我们声明了两个参数a和b，它们的类型都是Character，表示字符对象。</p></li><li><p><code>-&gt;</code>：箭头符号（-&gt;）用来分隔Lambda表达式的参数列表和方法体。</p></li><li><p><code>&#123;&#125;</code>：这部分是Lambda表达式的方法体。在这里，我们计算了map中b对应的值和map中a对应的值的差值，从而实现了按照值的降序排序。</p></li></ol><p>整个Lambda表达式的功能是创建了一个比较器，用来按照map中字符对应的值的降序对列表中的字符进行排序。</p><p>在这个例子中，Lambda表达式使得代码更加简洁，同时提供了对比较器的直接定义，而无需显式地编写一个类来实现Comparator接口。</p><p><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/description/">524. 通过删除字母匹配到字典里最长单词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; dictionary)</span> &#123;<br>        Collections.sort(dictionary,(a, b) -&gt;&#123;<br>            <span class="hljs-comment">//如果长度不同，按照长度从大到小进行排序</span><br>            <span class="hljs-keyword">if</span> (a.length() != b.length()) <span class="hljs-keyword">return</span> b.length() - a.length();<br>            <span class="hljs-comment">//如果长度相同，按照字典序进行排序</span><br>            <span class="hljs-keyword">return</span> a.compareTo(b);<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (String ss : dictionary)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ss.length();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)&#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == ss.charAt(j)) j++;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> ss;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开来写就是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(dictionary, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o1.length() != o2.length()) <span class="hljs-keyword">return</span> o2.length() - o1.length();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lambda表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层1~2.2.2</title>
    <link href="/2024/03/18/cn_%E7%BD%91%E7%BB%9C%E5%B1%8201%EF%BC%8C02.2.2/"/>
    <url>/2024/03/18/cn_%E7%BD%91%E7%BB%9C%E5%B1%8201%EF%BC%8C02.2.2/</url>
    
    <content type="html"><![CDATA[<p>讲一下上章节的一些心得吧：</p><p>在数据链路层有两种信道因而产生了对应信道的两种协议（PPP协议和CSMA&#x2F;CD协议），PPP协议用来通过拨号或者专线方式建立点对点连接发送数据。CSMA&#x2F;CD协议的基本原理是：每一个节点都共享网络传输信道，在每一个站点发送数据之前，都会检测信道是否空闲，如果空闲则发送，否则就等待；在信息发送之后，则对于冲突进行检测，当发现冲突的时候，就取消发送。最后交换机的出现解决了物理层因为总线共享而造成的冲突问题。虚拟局域网为了安全方面的考虑，将一个较大的局域网分割成为了一些较小的局域网，但是数据链路层一旦划分了VLAN标签之后，让接口带上不同的Vlan标签，无法使得A3、B4(不同标签的两个接口)相互通信了（起码你是在数据链路层解决不了了）。</p><p>本章节最重要的内容是：</p><p>（1)虚拟互连网络和两种服务、两个层面的概念。</p><p>（2）IP地址和MAC地址的关系。</p><p>（3）传统分类的IP地址和无分类间路由选择CIDR（后者是重点）。</p><p>（4）路由选择协议的工作原理。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="4-1-网络层的几个重要概念"><a href="#4-1-网络层的几个重要概念" class="headerlink" title="4.1 网络层的几个重要概念"></a>4.1 网络层的几个重要概念</h2><h3 id="4-1-1-网络层提供的两种服务"><a href="#4-1-1-网络层提供的两种服务" class="headerlink" title="4.1.1 网络层提供的两种服务"></a>4.1.1 网络层提供的两种服务</h3><p>在计算机网络领域，网络层应该向着运输层提供怎样的服务（“面向连接”还是“无连接”）曾经引起长期的争论。争论焦点实质就是：在计算机通信中，可靠交付应该由谁来负责？是网络还是端系统？</p><p>1、虚电路服务</p><ul><li><p>电信网使用昂贵的程控交换机，用面向连接的通信方式，使电信网络能够向用户(实际上就是电话机)提供可靠传输的服务。当两个计算机进行通信的步骤：   </p><blockquote><p>(1)应当先建立连接(但在分组交换中是建立一条虚电路VC)，以保证通信双方所需的一切网络资源。<br>(2)然后双方就沿着已建立的虚电路发送分组。<br>(3)这样的分组的首部就不需要填写完整的目的主机地址，而只需填写这条虚电路的编号(一个不大的整数)，因而减少了分组的开销。<br>(4)如果这种通信方式再使用可靠传输的网络协议，就可使所发送的分组<strong>无差错按序地到达终点，当然也不丢失、不重复。</strong><br>(5)在通信结束后，要释放建立的虚电路。</p></blockquote></li></ul><p>2、数据报服务</p><ul><li><p>因特网在设计上就采用了和电信网完全不同的思路。<br>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉(与电信网的交换机相比较)。</p><blockquote><p>(1)网络层向上只提供<strong>简单灵活的、无连接的、尽最大努力交付</strong>的数据报服务。网络在发送分组时不需要先建立连接。每个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)。<br>(2)<strong>网络层不提供服务质量的承诺。</strong>也就是说所传送的分组，可能出错、丢失、重复或失序，当然也不保证分组交付的时限。<br>这种设计思路的好处：<br>(1)网络的造价大大降低。<br>(2)运行方式灵活。<br>(3)能够适应多种应用。</p></blockquote></li></ul><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/%7BFA11DD46-067F-4214-AE28-E196ED6220BB%7D.png" style="zoom: 67%;" />       <img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/%7B803B31EA-00EA-40ea-8B91-8D4DB6E47F46%7D.png" style="zoom:67%;" /></p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240427171346.png" style="zoom: 67%;" /><h3 id="4-1-2-网络层的两个层面"><a href="#4-1-2-网络层的两个层面" class="headerlink" title="4.1.2 网络层的两个层面"></a>4.1.2 网络层的两个层面</h3><p>不同网络的两个主机相互通信，要经过若干个路由器转发分组得来，分组查找路由器的转发表，指明从接口转发到下一个路由器，按照共同选择的路由协议，通过多次交换路由信息而产生的。由此可见在路由器之间传送的信息有以下两大类：</p><p>第一类<strong>转发源主机和目的主机之间所传送的数据</strong>，把源主机所发送的分组，像接力赛跑那样从一个路由器转发到下一个路由器，最后将分组转发到目的主机。</p><p>第二类则是传送路由信息，根据路由协议所选择的路由算法，彼此不断地交换路由信息分组，目的是为了在路由器中创建路由表，由此导出为转发分组而用的转发表。这一类信息的传送是为了第一类数据传送而服务的。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240319112542.png" style="zoom: 67%;" /><p>​                                  使用图4-2的方法进行描述就是将网络抽象的划分为数据层面（或者<strong>转发层面</strong>）和<strong>控制层面</strong>。</p><p>在<strong>数据层面</strong>，每一个路由器根据本路由器生成的转发表，将查到的分组，从查找的对应的接口转发出去。为了提高转发效率，现在的路由器一般都通过硬件进行转发。</p><p>但是在<strong>控制层面</strong>则不同，路由器必须和相邻的路由器 交换信息，然后才能创建出本路由器的路由表。根据路由协议所使用的路由算法计算路由要使用软件 ，这就慢多了根据以上不难看出<strong>数据层面</strong>的问题比较单纯，因为路由器在转发分组的时候，是独立的根据本路由器的转发表转发分组的，但是在<strong>控制层面</strong>就比较复杂了因为路由器要创建路由表，就必须依靠许多路由器协同合作。</p><p>控制层面是各种协议工作的层面，他的<strong>作用是通过控制和管理各协议的运行使得路由器或交换机能够对整个网络的设备、链路和运行的协议有一个准确的了解，并在网络发生变化时也能及时感知并调整</strong>。</p><h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2 网际协议IP"></a>4.2 网际协议IP</h2><p>网际协议 IP 是 TCP&#x2F;IP 体系中两个最主要的协议之一，也是最重要的互联网标准协议之一。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP (Address Resolution Protocol)</li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)</li><li>网际组管理协议 IGMP (Internet Group Management Protocol)</li></ul><p>下图画出了这三个协议和网际协议 IP 的关系。在这一层中， ARP 画在最下面，因为 IP 经常要使用这个协议。 ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。这三个协议将在后面陆续介绍。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP&#x2F;IP体系中的网络层常常被称为网际层(internet layer)，或 IP 层。使用“网际层”这个名词的好处是强调。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240319143438.png" style="zoom:50%;" /><h3 id="4-2-1-虚拟互联网络"><a href="#4-2-1-虚拟互联网络" class="headerlink" title="4.2.1 虚拟互联网络"></a>4.2.1 虚拟互联网络</h3><p>我们知道，如果要在全世界范围内把数以百万计的网络都互连起来，并且能够互相通信，那么这样的任务一定非常复杂。其中会遇到许多需要解决的问题，如：</p><ul><li>不同的寻址方案；</li><li>不同的最大分组长度；</li><li>不同的网络接入机制；</li><li>不同的超时控制；</li><li>不同的差错恢复方法；</li><li>不同的状态报告方法；</li><li>不同的路由选择技术；</li><li>不同的用户接入控制；</li><li>不同的服务（面向连接服务和无连接服务）；</li></ul><p>能不能让大家都使用相同的网络，这样可使网络互连变得比较简单。答案是不行的。因为用户的需求是多种多样的，**没有一种单一的网络能够适应所有用户的需求 **。另外，网络技术是不断发展的，网络的制造厂家也要经常推出新的网络，在竞争中求生存。因此在市场上总是有很多种不同性能、不同网络协议的网络，供不同的用户选用。</p><p>从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><p>（1）物理层使用的中间设备叫做<strong>转发器</strong>(repeater)。</p><p>（2）数据链路层使用的中间设备叫做网桥或<strong>桥接器</strong>(bridge)<strong>交换机</strong>。</p><p>（3）网络层使用的中间设备叫做<strong>路由器</strong>(router)。</p><p>（4）在网络层以上使用的中间设备叫做<strong>网关</strong>(gateway)。用网关连接两个不兼容的系统需要在高层进行协议的转换。</p><p>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。这种使用 IP 协议的虚拟互连网络可简称为 IP 网（IP 网是虚拟的，但平常不必每次都强调“虚拟”二字）。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240319143717.png" style="zoom:50%;" /><p>其实上述图片强调的是<strong>互联网可以由多种异构网络构成</strong>。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240427173054.png" style="zoom:67%;" /><p>如果我们只从网络层考虑问题，那么 IP 数据报就可以想象是在网络层中传送， 其传送路径是：</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240427172932.png"></p><p>这样就不必画出许多完整的协议栈，使问题的描述更加简单。</p><p>有了虚拟互连网络的概念后，我们再讨论在这样的虚拟网络上如何寻址。</p><p><strong>沿着协议栈向下封装，向上解封</strong>的一个过程，通信向上层提供服务</p><h3 id="4-2-2-IP地址"><a href="#4-2-2-IP地址" class="headerlink" title="4.2.2 IP地址"></a>4.2.2 IP地址</h3><p>整个的互联网就是一个<strong>单一的、抽象</strong>的网络。 IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的 32 位的标识符。 IP 地址的结构使我们可以在互联网上很方便地进行寻址。 IP 地址现在由互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers)进行分配 。</p><h4 id="1、IP地址及其表示方法"><a href="#1、IP地址及其表示方法" class="headerlink" title="1、IP地址及其表示方法"></a>1、IP地址及其表示方法</h4><p>IP 地址的编址方法共经过了三个历史阶段。</p><p>（1）<strong>分类的 IP 地址</strong>。这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</p><p>（2）<strong>子网的划分</strong>。这是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</p><p>（3）<strong>构成超网</strong>。这是比较新的无分类编址方法。 1993 年提出后很快就得到推广应用。</p><p>所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是<strong>网络号</strong>(net-id)，它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是<strong>主机号</strong>(host-id)，它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。 由此可见，一个 IP 地址在<strong>整个互联网范围内是唯一的</strong>。</p><p>这种两级的 IP 地址可以记为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">IP地址 ::== &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;<br></code></pre></td></tr></table></figure><h4 id="2、分类的IP地址"><a href="#2、分类的IP地址" class="headerlink" title="2、分类的IP地址"></a>2、分类的IP地址</h4><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240427173502.png" style="zoom: 67%;" /><p>从上图可以看出：</p><ul><li>A 类、 B 类和 C 类地址的网络号字段（在图中这个字段是灰色的）分别为 1 个、 2 个和 3 个字节长，而在网络号字段的最前面有 1∼3 位的类别位，其数值分别规定为0， 10 和 110。</li><li>A 类、 B 类和 C 类地址的主机号字段分别为 3 个、 2 个和 1 个字节长。</li><li>D 类地址（前 4 位是 1110）用于多播（一对多通信）。</li><li>E 类地址（前 4 位是 1111）保留为以后用。</li></ul><p>从 IP 地址的结构来看， IP 地址并不仅仅指明一台主机，而是还指明了主机所连接到的网络。</p><p>把 IP 地址划分为 A 类、 B 类、 C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、 B 类和C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p><p>对主机或路由器来说， IP 地址都是 32 位的二进制代码。为了提高可读性，我们常常把32 位的 IP 地址中的每 8 位插入一个空格（但在机器中并没有这样的空格）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做点分十进制记法(dotted decimal notation)。下图是一个 B 类 IP 地址的表示方法。显然， 128.11.3.31 比10000000 00001011 00000011 00011111 书写起来要方便得多。</p><p>这种分类的IP地址由于网络号的位数是固定的，因此管理简单、使用方便、转发分组迅速，完全可以满足当时需求。后来，为了更加灵活地使用IP地址，出现了划分子网的方法，在IP地址的主机号中，插入一个子网号，把两级的IP地址变为三级的IP地址。但是，谁也没有预料到，互联网在20世纪90年代突然迅速地发展起来了。互联网从美国专用的科研实验网演变到世界范围开放的商用网!互联网用户的猛增，使得IP地址的数量面临枯竭的危险。这时，人们才注意到原来分类的IP地址在设计上确实有很不合理的地方。例如，一个A类网络地址块的主机号数目超过了1677 万个!当初美国的很多大学都可以分配到一个A类网络地址块。一个大学怎么会需要这样多的IP地址?但在互联网出现早期，人们就是认为IP地址是用不完的，不需要精打细算地分配。又如，一个 C类网络地址块可指派的主机号只有254个。但不少单位需要有300个以上的卫地址，那么干脆申请一个B类网络地址块(可以指派的主机号有6554个)， 宁可多要些卫地址，把多余的地址保留以后慢用。这样就浪费了不少的地址资源。<strong>即使后来采用了划分子网的方法，也无法解决IP地址枯竭的问题。</strong></p><p>于定，在20世纪90年代当发现IP地址在不久后将会枯竭时，种新的无分类编址方法就何世了。这种方法虽然也无法解决IP地址枯竭的问题，但可以推迟IP地址用尽的日子。下一节就介绍现在已普遍采用的这种编址方法。</p><h4 id="3-无分类编址CIDR"><a href="#3-无分类编址CIDR" class="headerlink" title="3. 无分类编址CIDR"></a>3. 无分类编址CIDR</h4><p> 它的正式名字是无分类域间路由选择 CIDR (Classless Inter-Domain Routing)。</p><h5 id="1-网络前缀"><a href="#1-网络前缀" class="headerlink" title="(1)网络前缀"></a>(1)网络前缀</h5><ul><li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li><li>CIDR 使用各种长度的 “网络前缀” ( network-prefix ) 来代替分类地址中的网络号和子网号。</li><li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。</li></ul><p><strong>无分类的两级编址的记法是：</strong> </p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240319220401.png"></p><p> CIDR 使用 “斜线记法” (slash notation)，它又称为 CIDR 记法，即在 IP 地址后面加上一个斜线 “<code>/</code>” ，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如CIDR表示的一个IP地址128.14.35.7&#x2F;20二进制IP地址的前20位是网络前缀（相当于原来的网络号），剩下的后面12位是主机号。</p><h5 id="（2）地址块"><a href="#（2）地址块" class="headerlink" title="（2）地址块"></a>（2）地址块</h5><p>CIDR 把网络前缀都相同的连续的 IP 地址组成 “CIDR 地址块”。</p><p>128.14.32.0&#x2F;20</p><p>③ 最小地址 : 最小地址就是主机号全0; 也就是地址块地址 ;</p><p>10000000000011100010<font color=LawnGreen>000000000000</font></p><p>④ 最大地址 : 最大地址就是主机号全1 ;</p><p>10000000000011100010<font color=LawnGreen>111111111111</font></p><p>⑤ 子网掩码 : 又称为“地址掩码” , 网络前缀对应的前20位为1,主机号对应的位数为0;</p><p>11111111111111111111000000000000</p><p>转为十进制为 : 255.255.240.0</p><h5 id="（3）地址掩码"><a href="#（3）地址掩码" class="headerlink" title="（3）地址掩码"></a>（3）地址掩码</h5><p>128.14.32.0&#x2F;20</p><p>⑤ 子网掩码 : 又称为“地址掩码” , 网络前缀对应的前20位为1,主机号对应的位数为0;</p><p>11111111111111111111000000000000</p><p>转为十进制为 : 255.255.240.0</p><p>将二进制的IP地址和地址掩码<strong>按位</strong>AND运算，即可得出网络地址。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240319183210.png"></p><p>CIDR地址中还有三个特殊的地址块，即：</p><ul><li>前缀n &#x3D; 32，即32位IP地址都是前缀，没有主机号。这其实就是一个IP地址。这其实就是一个IP地址。这个特殊地址用于<strong>主机路由</strong>。</li><li>前缀n &#x3D; 31，这个地址块中只有两个IP地址，其主机号分别为0和1。这个地址快用于<strong>点对点链路</strong>。</li><li>前缀n &#x3D; 0，同时IP地址也全是0，即0.0.0.0&#x2F;0。这用于<strong>默认路由</strong>。</li></ul><p>一个大的CIDR地址块中往往包含很多小地址快，所以在路由器的转发表中就利用较大的一个CIDR地址快来替代许多小的地址快。这种方法称为<strong>路由聚合</strong>。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240320143820.png" style="zoom:80%;" /><h4 id="4-IP地址的特点"><a href="#4-IP地址的特点" class="headerlink" title="4. IP地址的特点"></a>4. IP地址的特点</h4><p>(1)每一个IP地址都由网络前级和主机号两部分组成。从这个意义上说，IP地址是一种分等级的地址结构。分两个等级的好处是:第一，IP 地址管理机构在分配IP地址时只分配网络前缀(第一级)，而剩下的主机号(第二级)则由得到该网络前级的单位自行分配，这样就方便了下地址的管理:第二，<strong>路由器根据目的主机所连接的网络前缀(即地址块)来转发分组</strong>(而不考虑目的主机号)，这样就可以使转发表中的项目数大幅度减少，从而减少转发表所占的存储空间，缩短查找转发表的时间。</p><p>(2)实际上IP地址是标志台主机(或路由器)和一条链路的接口。<strong>当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络前缀必须是不同的</strong>。这种主机称为<strong>多归属主机</strong>(multihomed hos).由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的IP地址。这好比一一个建 筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路4号和上海路37号。</p><p>(3)按照互联网的观点，一个网络 (或子网)是指具有相同网络前缀的主机的集合，因此，用转发器或交换机连接起来的若于个局域网仍为一个网络，因为这些局域网都具有同样的网络前缀。具有不同网络前缀的局域网必须使用路由器进行互连。</p><p>(4)在IP地址中，所有分配到网络前缀的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇四</title>
    <link href="/2024/03/10/str4/"/>
    <url>/2024/03/10/str4/</url>
    
    <content type="html"><![CDATA[<h1 id="数字与字符间的转换"><a href="#数字与字符间的转换" class="headerlink" title="数字与字符间的转换"></a>数字与字符间的转换</h1><p>Integer.parseInt(a);将a转换成int类型</p><p>Integer.toString(a);将a转换成String类型</p><p>int[] cp &#x3D; score.clone();将数组score的值赋给cp</p><p><a href="https://leetcode.cn/problems/bulls-and-cows/description/">299. 猜数字游戏 - 力扣（LeetCode）</a></p><ul><li>这个题说白了还是统计字符类别的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHint</span><span class="hljs-params">(String secret, String guess)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bulls</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] cntS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] cntG = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; secret.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(secret.charAt(i) == guess.charAt(i)) ++bulls;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//这里相当于统计字符</span><br>                ++cntS[secret.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>                ++cntG[guess.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)&#123;<br>            <span class="hljs-comment">//理解一个点cntG[i], cntS[i]在同一位置上的字符肯定是相等的</span><br>            cows += Math.min(cntG[i], cntS[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.toString(bulls) + <span class="hljs-string">&quot;A&quot;</span> + Integer.toString(cows) + <span class="hljs-string">&quot;B&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/fizz-buzz/description/">412. Fizz Buzz - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fizzBuzz</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) cur += <span class="hljs-string">&quot;Fizz&quot;</span>;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) cur += <span class="hljs-string">&quot;Buzz&quot;</span>;<br>            <span class="hljs-keyword">if</span> (cur.length() == <span class="hljs-number">0</span>) cur = i + <span class="hljs-string">&quot;&quot;</span>;<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/relative-ranks/description/">506. 相对名次 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] ss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Gold Medal&quot;</span>, <span class="hljs-string">&quot;Silver Medal&quot;</span>, <span class="hljs-string">&quot;Bronze Medal&quot;</span>&#125;;<br>    <span class="hljs-keyword">public</span> String[] findRelativeRanks(<span class="hljs-type">int</span>[] score) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> score.length;<br>        String[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n];<br>        <span class="hljs-type">int</span>[] clone = score.clone();<br>        Arrays.sort(clone);<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) map.put(clone[i], n - <span class="hljs-number">1</span> - i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> map.get(score[i]);<br>            ret[i] = rank &lt; <span class="hljs-number">3</span> ? ss[rank] : String.valueOf(rank + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-time-difference/">539. 最小时间差 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> timePoints.size() * <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, idx = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++, idx += <span class="hljs-number">2</span>) &#123;<br>            String[] ss = timePoints.get(i).split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[<span class="hljs-number">0</span>]), m = Integer.parseInt(ss[<span class="hljs-number">1</span>]);<br>            nums[idx] = h * <span class="hljs-number">60</span> + m;<br>            nums[idx + <span class="hljs-number">1</span>] = nums[idx] + <span class="hljs-number">1440</span>;<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) ans = Math.min(ans, nums[i + <span class="hljs-number">1</span>] - nums[i]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/optimal-division/description/">553. 最优除法 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">optimalDivision</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            bs.append(nums[i]);<br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; n) bs.append(<span class="hljs-string">&quot;/&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>)&#123;<br>            bs.insert(bs.indexOf(<span class="hljs-string">&quot;/&quot;</span>) + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;(&quot;</span>);<br>            bs.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bs.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/complex-number-multiplication/">537. 复数乘法 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">complexNumberMultiply</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>        String[] ss1 = num1.split(<span class="hljs-string">&quot;\\+|i&quot;</span>), ss2 = num2.split(<span class="hljs-string">&quot;\\+|i&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> parse(ss1[<span class="hljs-number">0</span>]), b = parse(ss1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> parse(ss2[<span class="hljs-number">0</span>]), d = parse(ss2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> a * c - b * d, B = b * c + a * d;<br>        <span class="hljs-keyword">return</span> A + <span class="hljs-string">&quot;+&quot;</span> + B + <span class="hljs-string">&quot;i&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/string-compression/description/">443. 压缩字符串 - 力扣（LeetCode）</a></p><p>代码整的没太懂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compress</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (idx &lt; n &amp;&amp; cs[idx] == cs[i]) idx++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> idx - i;<br>            cs[j++] = cs[i];<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> j, end = start;<br>                <span class="hljs-keyword">while</span> (cnt != <span class="hljs-number">0</span>) &#123;<br>                    cs[end++] = (<span class="hljs-type">char</span>)((cnt % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    cnt /= <span class="hljs-number">10</span>;<br>                &#125;<br>                reverse(cs, start, end - <span class="hljs-number">1</span>);<br>                j = end;<br>            &#125;<br>            i = idx;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cs, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> cs[start];<br>            cs[start] = cs[end];<br>            cs[end] = t;<br>            start++; end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/roman-to-integer/submissions/516216930/">13. 罗马数字转整数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">romanToInt</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] gra1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">500</span>,<span class="hljs-number">1000</span>&#125;;<br>        <span class="hljs-type">char</span>[] gra2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>&#125;;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) map.put(gra2[i], gra1[i]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; -<span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> map.get(s.charAt(i));<br>            <span class="hljs-keyword">if</span>(v &gt;= max)&#123;<br>                ans += v;<br>                max = v;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans -= v;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/integer-to-roman/">12. 整数转罗马数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">900</span>,<span class="hljs-number">1000</span>&#125;;<br>        String[] key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;CD&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>&#125;;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>value.length - <span class="hljs-number">1</span>; i &gt; -<span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> value[i];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> key[i];<br>            <span class="hljs-keyword">while</span>(num &gt;= val)&#123;<br>                num -= val;<br>                ret.append(symbol);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/magical-string/submissions/516229608/">481. 神奇字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">magicalString</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//这里定义n + 2大小的目的是防止while循环里j++加了两次而造成数组越界</span><br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; cnt[<span class="hljs-number">1</span>] = cnt[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, i = <span class="hljs-number">2</span>, c = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>            c ^= <span class="hljs-number">3</span>;<br>            cnt[j++] = c;<br>            <span class="hljs-keyword">if</span>(cnt[i++] == <span class="hljs-number">2</span>) cnt[j++] = c;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; b &lt; n; b++) ans += <span class="hljs-number">2</span> - cnt[b];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种方法太过于难以像到了，尤其是 <code>C ^= 3</code> 这一句。使用下面进行模拟就比较容易理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">magicalString</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;122&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">BLX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-comment">//这里注意一定是从2开始的，脑子又不灵光了</span><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (x &lt; n)&#123;<br><span class="hljs-keyword">if</span> (bs.charAt(x) == <span class="hljs-string">&#x27;1&#x27;</span>) bs.append(BLX.repeat(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">else</span> bs.append(BLX.repeat(<span class="hljs-number">2</span>));<br>            <span class="hljs-comment">//这一句这样写感觉有一点丑陋</span><br>BLX = BLX == <span class="hljs-string">&quot;1&quot;</span> ? <span class="hljs-string">&quot;2&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>;<br>            <span class="hljs-comment">//BLX = BLX.equals(&quot;1&quot;) ? &quot;2&quot; : &quot;1&quot;;</span><br>x++;<br>&#125;<br>System.out.println(bs.toString());<br><span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) ans += <span class="hljs-string">&#x27;2&#x27;</span> - bs.charAt(i) ;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种方法对于方法的使用和利用很好</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章节</title>
    <link href="/2024/03/06/cn_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2024/03/06/cn_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>数据链路层属于计算机网络的低层，数据链路层使用的信道主要有以下两种类型：</p><p>（1）点对点信道：这种信道使用一对一的点对点通信方式。</p><p>（2）广播信道：这种信道使用一对多的广播通信的方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机数据的发送。</p><p>局域网虽然是一个网络，但是并不将它放在网络层进行讨论。这是因为网络层讨论的问题是多个网络互连的问题，是讨论分组怎样从一个网络通过路由器，转发到另一个网络种。本章研究的是在同一个局域网中，分组怎样从一台主机传送到另一台主机，但并不经过路由器的转发。从整个互联网来看，<strong>局域网仍然属于数据链路层的范围</strong>。</p><p>本章的重要内容是：</p><p>（1）数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议和CSMA&#x2F;CD协议）的特点。</p><p>（2）数据链路层的三个基本问题：封装成帧、透明传输、差错检错。</p><p>（3）以太网MAC层的硬件地址。</p><p>（4）适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。</p><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><p>两台主机在进行通信时候数据链路层所处的地位</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240306170156.png"></p><p><img src="https://s2.loli.net/2024/03/06/TdDpYgXGZQOjEJV.png"></p><p>主机H1和主机H2都有完整的五层协议栈，但是在路由器转发分组的时候所使用的协议栈只有下三层。</p><h2 id="3-1-数据链路层的几个共同问题"><a href="#3-1-数据链路层的几个共同问题" class="headerlink" title="3.1 数据链路层的几个共同问题"></a>3.1 数据链路层的几个共同问题</h2><h3 id="3-1-1-数据链路和帧"><a href="#3-1-1-数据链路和帧" class="headerlink" title="3.1.1 数据链路和帧"></a>3.1.1 数据链路和帧</h3><p>（1） <strong>链路</strong>：就是从一个结点到相邻结点的一段<em><strong>物理线路</strong></em>，而中间没有任何其他交换结点。<br>（2）<strong>数据链路</strong>：是指把<em><strong>实现通信协议的硬件和软件加到链路</strong></em>上，就构成了数据链路。常用的方法是使用<strong>网络适配器</strong>（既有硬件同时也包括软件）来实现这些协议。</p><p>下面再介绍点对点信道的数据链路层的协议数据单元——帧。</p><p>数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是IP数据报(或简称为数据报、分组或包)。</p><p>为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图3-3(a)所示的三层模型。在这种三层模型中，不管在哪一段链路上的通信(主机和路由器之间或两个路由器之间)，我们都看成是<strong>节点和节点</strong>的通信(如图中的节点A和节点B)，而每个节点只有下三层——网络层、数据链路层和物理层。</p><p><img src="https://s2.loli.net/2024/03/06/xkCBaIisEtZ78QW.png"></p><p>点对点信道的数据链路层在进行通信时的主要步骤如下:</p><p>(1)节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。</p><p>(2)节点A把封装好的帧发送给节点B的数据链路层。</p><p>(3)若节点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层;否则丢弃这个帧。</p><p>数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如图3-3(b)所示。</p><h3 id="3-1-2-三个基本问题"><a href="#3-1-2-三个基本问题" class="headerlink" title="3.1.2 三个基本问题"></a>3.1.2 三个基本问题</h3><p>封装成帧、透明传输、差错检错</p><h4 id="1、封装成帧"><a href="#1、封装成帧" class="headerlink" title="1、封装成帧"></a>1、<strong>封装成帧</strong></h4><p>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。图3-4表示用帧首部和帧尾部封装成帧的一般概念。我们知道，分组交换的一个重要概念就是 : 所有在互联网上传送的数据都以分组(即IP数据报)为传送单位。网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限最 大传送单元MTU (Maximum Transfer Unit)。图3-4给出了帧的首部和尾部的位置，以及帧的数据部分与MTU的关系。</p><p><img src="https://s2.loli.net/2024/03/06/Q1HJjKgv5iAZc9W.png"></p><h4 id="2、透明传输"><a href="#2、透明传输" class="headerlink" title="2、透明传输"></a>2、<strong>透明传输</strong></h4><p>我们在传输信息中会遇到这么一个问题：</p><p><img src="https://s2.loli.net/2024/03/06/xQulS5vcIwPAOER.png"></p><p>如果说我们对传输的信息有要求，要求信息中不能存在帧定界符，这其实就是不透明传输。不透明传输其实没有什么意义的，对于传输的信息内容都有要求的话，那么我们还能传输什么信息呢？所以我们就要求透明传输。</p><p>透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。也就是说：数据链路层传送的比特组合必须是不受限制的。那么我们怎么样才能实现透明传输的问题呢？</p><p>（1）面向字节的物理链路使用字节填充（或称字符传输）的方法实现透明传输。<br>（2）面向比特的物理链路使用比特填充的方法实现透明填充。</p><p>例如使用采用字节填充法解决透明传输的问题</p><p>（1）字节填充或字符填充——发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。<br>（2）接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>（3）如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</p><p><img src="https://s2.loli.net/2024/03/06/Orsd2BIA8zlJau5.png"></p><h4 id="3、差错检错"><a href="#3、差错检错" class="headerlink" title="3、差错检错"></a>3、<strong>差错检错</strong></h4><p>循环冗余检验</p><h2 id="3-2-点对点协议ppp"><a href="#3-2-点对点协议ppp" class="headerlink" title="3.2 点对点协议ppp"></a>3.2 点对点协议ppp</h2><h3 id="3-2-1-PPP协议的特点"><a href="#3-2-1-PPP协议的特点" class="headerlink" title="3.2.1 PPP协议的特点"></a>3.2.1 PPP协议的特点</h3><h4 id="1-PPP协议应该满足的需求"><a href="#1-PPP协议应该满足的需求" class="headerlink" title="1. PPP协议应该满足的需求"></a>1. PPP协议应该满足的需求</h4><p>（1）简单</p><p>(2)封装成帧：PPP协议必须规定特殊的字符作为帧定界符(即标志一个帧的开始和结束的字符)，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</p><p>(3) 透明性：PPP协议必须保证数据传输的透明性。这就是说，如果数据中碰巧出现了和帧定界符样的比特组合时，就要采取有效的措施来解决这个问题(见3.22节)。</p><p>(4)多种网络层协议：PPP协议必须能够在同一条物理链路上同时支持多种网络层协议(如IP和IPX等)的运行。当点对点链路所连接的是局域网或路由器时，PPP协议必须一同时支持在链路所连接的局域网或路由器士运行的各种网络层协议。</p><p>(5)多种类型链路：除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。例如，串行的(一次只发送一个比特)或并行的(-次并行地发送多个比特)，同步的或异步的，低速的或高速的，电的或光的，交换的(动态的)或非交换的(静态的)点对点链路。</p><p>（6）差错检错</p><p>（7）检测连接状态</p><p>（8）最大传送单元</p><p>（9）网络层地址协商</p><p>（10）数据压缩协商</p><h4 id="2-PPP协议的组成"><a href="#2-PPP协议的组成" class="headerlink" title="2. PPP协议的组成"></a>2. PPP协议的组成</h4><p>(1)一个将IP数据报封装到串行链路的方法。PPP 既支持异步链路(无奇偶检验的8比特数据)，也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分。这个信息部分的长度受最大传送单元MTU的限制。</p><p>(2)一个用来建立、配置和测试数据链路连接的链路控制协议LCP(LinkControlProtocol)。通信的双方可协商-些选项。 在RFC 1661中定义了11种类型的 LCP分组。</p><p>(3)-套网络控制协议 NCP (Network Control Protocol)”，其中的每一个协议支持不同的网络层协议，如IP、 OSI的网络层、DECnet 和AppleTalk等。</p><h3 id="3-2-2-PPP协议的帧格式"><a href="#3-2-2-PPP协议的帧格式" class="headerlink" title="3.2.2 PPP协议的帧格式"></a>3.2.2 PPP协议的帧格式</h3><h4 id="1-各个字段的意义"><a href="#1-各个字段的意义" class="headerlink" title="1.各个字段的意义"></a>1.各个字段的意义</h4><p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p><blockquote><p>（1）对各种协议数据报的<code>封装方法</code>（封装成帧）；<br>（2）<code>链路控制协议LCP</code>：用于建立，配置以及测试数据链路的连接；<br>（3）<code>一层网络控制协议NCPs</code>：其中每一个协议支持不同的网络层协议；</p></blockquote><p><img src="https://s2.loli.net/2024/03/07/eAYrXnZQH6axlMd.png"></p><p>首部</p><p>首部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的开始。</p><p>首部中的地址字段A规定为0xFF(即11111111)。</p><p>首部中的控制字段C规定为0x03(即00000011)。</p><p>首部中的2字节的协议字段：</p><p><img src="https://s2.loli.net/2024/03/07/l3uy6NwIGaYc5zj.png"></p><p>信息字段</p><p>信息字段的长度是可变的，不超过1500字节</p><p>尾部</p><p>尾部中的第一个字段(2个字节)是使用CRC的帧检验序列FCS。</p><p>尾部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的结束。</p><h4 id="2-字节填充"><a href="#2-字节填充" class="headerlink" title="2.字节填充"></a>2.字节填充</h4><p>当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。也就是之前提到过的实现透明传输。</p><p>面向字节的异步链路</p><p>当PPP使用异步传输时，它把转移符定义为0x7D，并使用字节填充。</p><p>RFC1662规定了如下填充方法：</p><p>（1）把信息字段中出现的每一个0x7E字节转变为2字节序列(0x7D，0x5E)。</p><p>（2）若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则把转义字符0x7D转变为2字节序列(0x7D，0x5D)。</p><p>（3）若信息字段中出现ASCII码的控制字符(即数值小于0x20的字符)，则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列的(0x7D，0x23)。</p><p><img src="https://s2.loli.net/2024/03/07/zi6xGRBCaNP4kMp.png"></p><h4 id="3-零比特填充"><a href="#3-零比特填充" class="headerlink" title="3.零比特填充"></a>3.零比特填充</h4><p>面向比特的同步链路</p><p>面向比特的同步链路我们一般使用比特填充法插入比特0。</p><p>零比特填充的具体方法：</p><p>（1）在发送端先扫描整个信息字段(通常使用硬件实现，但也可以用软件实现，但是会慢一些)。</p><p>（2）只要发现有5个连续的1，则立即填入一个0。</p><p>（3）接收端在收到一个帧时，先找到标志字段F以确定帧的边界，接着再用硬件对其中的比特流进行扫描，每当发现5个连续1时，就把5个连续1后的一个0删除，以还原成原来的信息比特流。</p><p><img src="https://s2.loli.net/2024/03/07/tI5dr1xTCaXLgDW.png"></p><h3 id="3-2-3-PPP协议的工作状态"><a href="#3-2-3-PPP协议的工作状态" class="headerlink" title="3.2.3 PPP协议的工作状态"></a>3.2.3 PPP协议的工作状态</h3><p><img src="C:\Users\17083\AppData\Roaming\Typora\typora-user-images\image-20240307094034047.png" alt="image-20240307094034047"></p><h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h2><h3 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h3><p>局域网的最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限</p><p>局域网具有如下优点：</p><p>（1）具有广播功能，从一个站点可以很方便的访问全网。局域网上的主机可以共享连接在局域网上的各种硬件和软件资源。</p><p>（2）便于系统的扩展和逐渐的演变，各个设备的位置可以灵活调整和转变。</p><p>（3）提高了系统的可靠性可用性和生存性。</p><p><img src="https://s2.loli.net/2024/03/12/NjlUOP9vwY1S6Fr.png"></p><p><img src="https://s2.loli.net/2024/03/12/GTQlPpjkhaF17LH.png"></p><h3 id="3-3-2-CSMA-CD协议"><a href="#3-3-2-CSMA-CD协议" class="headerlink" title="3.3.2 CSMA&#x2F;CD协议"></a>3.3.2 CSMA&#x2F;CD协议</h3><p>（1）采用无连接的工作方式，以太网提供的服务是不可靠的交付，即最大努力的交付，当目的站收到有差错的数据帧就丢弃此帧，其他什么也不做。差错的纠正由高层决定。如果高层发现丢失了一些数据而进行重传，但是以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p><p>（2）以太网的发送数据都采用了<strong>曼彻斯特编码</strong>。</p><ul><li><p>CSMA&#x2F;CD含义：载波监听多点接入&#x2F;冲突检测</p></li><li><p>多点接入，表示许多计算机以多点接入的方式连接在一根总线上</p></li><li><p>载波监听，指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据。如果有，则暂时不要发送数据，以免发生碰撞。</p></li><li><p>冲突检测，就是计算机边发送数据边检测信道上的信号电压大小。</p><p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</p><p><img src="https://s2.loli.net/2024/03/13/63r2xDJ1MTePBSk.png"></p><p><img src="C:\Users\17083\AppData\Roaming\Typora\typora-user-images\image-20240313173859400.png" alt="image-20240313173859400"></p><p>显然在使用CSMA&#x2F;CD协议时候，一个站不可能同时进行发送和接收（但是必须边发送边监听信道）。因此只能进行<strong>半双工通信</strong>。</p></li></ul><p><img src="https://s2.loli.net/2024/03/13/BXbZrE25oUGyH7A.png"></p><p>发生碰撞的站在停止发送数据之后，要推迟（退避）一个随机时间才能发送数据。</p><p>退避算法：<br>1.从[0，1，2， …，（2^k-1）]中随机选一个数，记为r。重传应在r倍争用期之后进行。k&#x3D;Min[重传次数，10]，即k小于10时为重传次数，最大不超过10 。<br>2.若重传超过16次还是不成功，则说明信道中数据过多，放弃重传，向高层报告。</p><img src="https://s2.loli.net/2024/03/13/4rlEeIytqKOuBzw.png" style="zoom:50%;" /><p>但凡小于64字节的帧都是由于冲突而异常终止的无效帧。只要收到这种无效帧，就应当立即将其丢弃。</p><p>先听后发、边听边发、冲突停止、延迟重发。</p><h2 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h2><h3 id="3-4-1在物理层扩展以太网"><a href="#3-4-1在物理层扩展以太网" class="headerlink" title="3.4.1在物理层扩展以太网"></a>3.4.1在物理层扩展以太网</h3><h4 id="1-1-使用光纤扩展"><a href="#1-1-使用光纤扩展" class="headerlink" title="1.1 使用光纤扩展"></a>1.1 使用光纤扩展</h4><p>主机使用光纤和一对光纤调制解调器连接到集线器，很容易使主机和几公里以外的集线器相连接</p><p><img src="https://s2.loli.net/2024/03/14/paMdziomKc1leJn.png"></p><h4 id="1-2-使用集线器扩展"><a href="#1-2-使用集线器扩展" class="headerlink" title="1.2 使用集线器扩展"></a>1.2 使用集线器扩展</h4><p>将多个以太网段连成更大的、多级星形结构的以太网，如某个部门有一系，二系，三系通过集线器扩展</p><p><img src="https://s2.loli.net/2024/03/14/gNsDdUJurLZIjWH.png"></p><p>优点：</p><p>1.使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信</p><p>2.扩大了以太网覆盖的地理范围。</p><p>缺点：</p><p>1.碰撞域增大了，但总的吞吐量并未提高。</p><p>2.如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来<br>碰撞域：碰撞域（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络碰撞域越大，发生碰撞的概率越高</p><h3 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&spm=1001.2101.3001.7020">数据链路层</a>扩展以太网</h3><ul><li>扩展以太网更常用的方法是在数据链路层进行</li><li>早期使用网桥，现在使用以太网交换机</li></ul><p><img src="https://s2.loli.net/2024/03/14/ALQvRzlxaN9SEr2.png"></p><p>现在使用的方法是以太网交换机，以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，可见交换机工作在数据链路层。以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>①全双工方式，交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据</strong>，以太网交换机由于使用了专用的交换结构芯片，通过硬件来转发就比靠软件转发的网桥速度快得多，所以交换机的出现很快的就淘汰掉了网桥。</p><p>以太网交换机是一种即插即用的设备其内部的帧交换表（又称为地址表）通过自学习的算法自动逐渐建立的实际上这种交换表就是一个<strong>②内容可寻址存储器</strong>。</p><p><font color=Yellow>物理层因为总线共享而造成的冲突在数据链路层因为交换机的①②两个特性得以解决</font></p><p>建立转发表是通过不断的发送广播来实现的，但是若有的网络为环形网络，此时这个数据帧会一直在网络在“转圈圈”，在透明网桥中，为了避免这个问题，引入了生成树算法，无环路的树状结构。</p><p><img src="https://s2.loli.net/2024/03/14/zTs4ylKGwm3qJ9i.png"></p><h3 id="3-4-3-虚拟机局域网"><a href="#3-4-3-虚拟机局域网" class="headerlink" title="3.4.3 虚拟机局域网"></a>3.4.3 虚拟机局域网</h3><p>虚拟局域网（<a href="https://so.csdn.net/so/search?q=Virtual&spm=1001.2101.3001.7020">Virtual</a> Local Area Network，VLAN）是一组逻辑上的设备和用户，通过端口分配、MAC地址分配等方式将同一局域网内的主机划分为不同的区域（VLAN），不同区域之间的主机无法直接通信（即使它们都在同一个有线局域网中），而同一区域内的主机之间可以正常通信，这就好像一个局域网一样，因此叫做虚拟局域网。与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点： 网络设备的移动、添加和修改的管理开销减少；可以控制广播活动；可提高网络的安全性。</p><p>  在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互隔离的。不同的广播域之间想要通信，需要通过一个或多个路由器。这样的一个广播域就称为VLAN。</p><p>划分标准</p><p>  工作站到VLAN的映射有几种方法。通过端口、基于MAC地址是常见的划分标准。</p><h5 id="VLAN标签"><a href="#VLAN标签" class="headerlink" title="VLAN标签"></a>VLAN标签</h5><p>  当不同的VLAN中的站连接在同一交换机时，交换机确保流量不在两个VLAN之间泄漏，无论这些站使用哪种类型的以太网接口。当多个VLAN跨越多个交换机（中继）时，在以太网帧发送到另一台交换机之前，需要使用VLAN来标记该帧的归属。</p><p><img src="https://s2.loli.net/2024/03/14/naFl6PoVZNtE9wQ.png"></p><p>数据链路层一旦划分了vlan标签之后就无法让A3、B4之间相互通信了。（数据链路层就无法解决了）</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2024/03/02/sort/"/>
    <url>/2024/03/02/sort/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>可以先这么想，</p><ul><li>对于外层循环，就是五个数字要比较四轮（又例如，99个数字比较98轮），n 个数字比较n - 1轮。</li><li>对于内层循环，（以第一次循环的时候为例子）五个数字需要比较四次（才能将最大的那一个沉底），（以第一次循环的时候为例子）99个数字比较98次（才能将最大的那一个沉底）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-comment">//比如说5个数字，就总共比较四轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//比如说5个数字，那么第一轮就比较四次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length - i; j++)&#123;<br>            <span class="hljs-comment">//每一次都会和下面的数字进行比较</span><br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[j + <span class="hljs-number">1</span>];<br>                nums[j + <span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>新的理解，将下标逐次赋给min_index的时候，并不需要把最后一个（即n - 1）赋给它，因为每次遍历已经将最小值置换到前面去了，最后一个肯定是最大的那一个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length, min_index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//这里相当于将每一个元素的下标逐个赋给min_index</span><br>        min_index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">//将每一个元素和自己后面的元素进行比较（i前面的元素一定是每一轮中的最小值）</span><br>            <span class="hljs-keyword">if</span> (arr[min_index] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">//然后记录最小元素的下标</span><br>                min_index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//通过本轮最小元素的下标将元素置换到前面去（每一轮的i）</span><br>        <span class="hljs-keyword">if</span>(i != min_index)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[min_index];<br>            arr[min_index] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>这个版本的插入排序和希尔排序都挺好记忆的，（对我而言）是最优的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-comment">//可以进行i = 1的优化，但是这个就很刻意了（追求时间复杂度）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i, v = arr[i];<br>        <span class="hljs-comment">//这里只能是arr[j] =arr[--j];只能先减去，后赋值，不能j--</span><br>        <span class="hljs-keyword">while</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j - <span class="hljs-number">1</span>] &gt; v) arr[j] = arr[--j];<br>        arr[j] = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//每次到这里的时候才会/2操作，先判断再除法所以gap = 1的时候，仍然在里面</span><br>        gap /= <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//其实可以将这里优化为 i = gap,因为如果i &lt; gap的话它就会无效遍历</span><br>        <span class="hljs-comment">//可以进行i = gap的优化，但是这个就很刻意了（追求时间复杂度）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">//它将用于在数组中向后查找应该插入v的位置。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (j - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j - gap] &gt;= v) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br>            arr[j] = v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>是我太无知了，将这个程序Debug了四五次，我还是把这个程序先背过吧，以后多写几遍慢慢理解</p><p>System.arraycopy();中的五个参数分别是：</p><p>源数组，（复制）起始位置，目的数组，（拷贝）起始位置，复制的长度。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240323140042.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge_Sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_Sort(l, mid);<br>    merge_Sort(mid + <span class="hljs-number">1</span>, r);<br>    merge(l, mid, r);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-keyword">while</span> (l &lt;= m &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span> (arr0[l] &lt;= arr0[j]) arr1[idx] = arr0[l++];<br>        <span class="hljs-keyword">else</span> arr1[idx] = arr0[j++];<br>        idx++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt;= m) arr1[idx++] = arr0[l++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) arr1[idx++] = arr0[j++];<br>    <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> - s &gt;= <span class="hljs-number">0</span>) System.arraycopy(arr1, s, arr0, s, r + <span class="hljs-number">1</span> - s);<br>&#125;<br></code></pre></td></tr></table></figure><p>以前一口气写下五个排序是我不敢想的</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>它第一次循环下来肯定是左边的数字小于参考值，右边的数全部大于参考值，（参考值就可以完全归位了）</p><ul><li>之前，我一直有一个疑问为啥要<strong>先从</strong>右边找（第一个比tmp小的值）呢？为啥我不可以从左边先找一个比参考值（tmp）大的数字呢</li></ul><p>在进行循环比较的时候，一定是<font color=RED><code>tmp &lt;= arr[j]</code>，</font>如果忘了等于号就会导致从左边到右边第一个数字（也就是tmp）被选中交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = r, tmp = arr[l];<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-comment">//从右边向着左边找一个比tmp小的数字</span><br>        <span class="hljs-keyword">while</span> (tmp &lt;= arr[j] &amp;&amp; j &gt; i) j--;<br>        <span class="hljs-comment">//从左边向着右边找到第一个比tmp大的数字</span><br>        <span class="hljs-keyword">while</span> (tmp &gt;= arr[i] &amp;&amp; j &gt; i) i++;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            arr[i] ^= arr[j];<br>            arr[j] ^= arr[i];<br>            arr[i] ^= arr[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这两句相当于参考值和i,j相遇时候（小于参考值的那一个）进行交换</span><br>    arr[l] = arr[j];<br>    arr[j] = tmp;<br>    <span class="hljs-comment">//其实就是j - 1终结的循环</span><br>    quick_sort(arr, l, j - <span class="hljs-number">1</span>);<br>    quick_sort(arr, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当二者（i,j）相遇之后，那一个数字肯定比参考值小（tmp），才能进行交换操作，使得参考值左边的数字都小于自己，参考值右边的数字都大于自己。</li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>, max = -min;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e : arr) &#123;<br>           min = Math.min(min, e);<br>           max = Math.max(max, e);<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bucketSize</span> <span class="hljs-operator">=</span> (max - min) / arr.length + <span class="hljs-number">1</span>;  <span class="hljs-comment">//根据区间范围和数量确定单个桶范围</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;  <span class="hljs-comment">//根据区间范围和单个桶的数量确定需要多少个桶</span><br>       List&lt;Integer&gt;[] lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[bucketCount];<br>       Arrays.setAll(lists, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) &#123;<br>           lists[(e - min) / bucketSize].add(e);  <span class="hljs-comment">//类似于求多少个桶</span><br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> list : lists) list.sort(Comparator.comparing(e -&gt; e));<br>       <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : lists[i])<br>               arr[idx++] = e;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>不能处理负数,如果有负数就得加偏移量。</p><p>有一些像我之前写过的统计字符串中的字符那一道题目，应该也是10个中最简单的一个了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) &#123;<br>            <span class="hljs-keyword">if</span> (array[e] == <span class="hljs-literal">null</span>) array[e] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> array[e] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array[i] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> array[i];<br>                <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>) arr[idx++] = i;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>核心思想: 用0~9表示位上面的数,总共10个桶,遍历maxLen次,每次遍历当前位,将每个数放到自己值的位置。时间复杂度稳定O(k * n),不能处理负数,如果有负数就得加偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    LinkedList&lt;Integer&gt;[] lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>[<span class="hljs-number">10</span>];<br>    Arrays.setAll(lists, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());  <span class="hljs-comment">//这里使用linkedList比较好,使用linkedlist方便删除</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) maxLen = Math.max(getLength(e), maxLen);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= maxLen; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) lists[getIndexValue(i, e)].add(e);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> list : lists) &#123;<br>            <span class="hljs-keyword">while</span> (!list.isEmpty()) &#123;<br>                arr[idx++] = list.poll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            num /= <span class="hljs-number">10</span>;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getIndexValue</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res = num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇三</title>
    <link href="/2024/03/02/str3/"/>
    <url>/2024/03/02/str3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符的统计"><a href="#字符的统计" class="headerlink" title="字符的统计"></a>字符的统计</h1><p><a href="https://leetcode.cn/problems/first-unique-character-in-a-string/description/">387. 字符串中的第一个唯一字符 - 力扣（LeetCode）</a></p><p>这种用来统计词频的方法可以作为一个模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) arr[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;n ; i++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map.put(c, map.getOrDefault(c, 0)+1);</code>这里不能使用<code>map.put(c, map.getOrDefault(c, 0)++);</code>这里错了好几次了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; f  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) f.put(c, f.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(f.get(s.charAt(i)) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-difference/description/">389. 找不同 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">findTheDifference</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) counter[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(--counter[c - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">findTheDifference</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            res ^= c;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            res ^= c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine.toCharArray())&#123;<br>            cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : ransomNote.toCharArray()) &#123;<br>            cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span> (cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            table[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            table[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span> (table[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/group-anagrams/description/">49. 字母异位词分组 - 力扣（LeetCode）</a></p><p>这种方法真的整的……</p><p>getOrDefault方法接受两个参数：一个键（key）和一个默认值（defaultValue）。如果键存在于HashMap中，则返回与该键关联的值；否则，返回默认值。</p><p>在这个例子中，我们尝试获取与键（key）关联的值。如果键不存在，我们将创建一个新的<code>ArrayList&lt;String&gt;</code>作为默认值。这样，我们可以确保list变量始终包含一个有效的字符串列表，无论键是否存在于HashMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">char</span>[] array = str.toCharArray();<br>            Arrays.sort(array);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array);<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的思想有点类似于桶排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                counts[str.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span><br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (counts[i] != <span class="hljs-number">0</span>) &#123;<br>                    sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + i));<br>                    sb.append(counts[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> sb.toString();<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/description/">451. 根据字符出现频率排序 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">frequencySort</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">frequency</span> <span class="hljs-operator">=</span> map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            map.put(c, frequency);<br>        &#125;<br>        List&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Character&gt;(map.keySet());<br>        Collections.sort(list, (a, b) -&gt; map.get(b) - map.get(a));<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">frequency</span> <span class="hljs-operator">=</span> map.get(c);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; frequency; j++) &#123;<br>                sb.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">frequencySort</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxFreq</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">frequency</span> <span class="hljs-operator">=</span> map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            map.put(c, frequency);<br>            maxFreq = Math.max(maxFreq, frequency);<br>        &#125;<br>        StringBuffer[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>[maxFreq + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= maxFreq; i++) &#123;<br>            buckets[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">frequency</span> <span class="hljs-operator">=</span> entry.getValue();<br>            buckets[frequency].append(c);<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxFreq; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> buckets[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> bucket.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; i; k++) &#123;<br>                    sb.append(bucket.charAt(j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reconstruct-original-digits-from-english/">423. 从英文中重建数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">originalDigits</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            c.put(ch, c.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        cnt[<span class="hljs-number">0</span>] = c.getOrDefault(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">0</span>);<br>        cnt[<span class="hljs-number">2</span>] = c.getOrDefault(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-number">0</span>);<br>        cnt[<span class="hljs-number">4</span>] = c.getOrDefault(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-number">0</span>);<br>        cnt[<span class="hljs-number">6</span>] = c.getOrDefault(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">0</span>);<br>        cnt[<span class="hljs-number">8</span>] = c.getOrDefault(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">0</span>);<br><br>        cnt[<span class="hljs-number">3</span>] = c.getOrDefault(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-number">0</span>) - cnt[<span class="hljs-number">8</span>];<br>        cnt[<span class="hljs-number">5</span>] = c.getOrDefault(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">0</span>) - cnt[<span class="hljs-number">4</span>];<br>        cnt[<span class="hljs-number">7</span>] = c.getOrDefault(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">0</span>) - cnt[<span class="hljs-number">6</span>];<br><br>        cnt[<span class="hljs-number">1</span>] = c.getOrDefault(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">0</span>) - cnt[<span class="hljs-number">0</span>] - cnt[<span class="hljs-number">2</span>] - cnt[<span class="hljs-number">4</span>];<br><br>        cnt[<span class="hljs-number">9</span>] = c.getOrDefault(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>) - cnt[<span class="hljs-number">5</span>] - cnt[<span class="hljs-number">6</span>] - cnt[<span class="hljs-number">8</span>];<br><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; cnt[i]; ++j) &#123;<br>                ans.append((<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;0&#x27;</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/robot-return-to-origin/">657. 机器人能否返回原点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间复杂度：O(n)</span><br><span class="hljs-comment">// 空间复杂度：如果采用 toCharArray，则是 O（n）;如果使用 charAt，则是 O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judgeCircle</span><span class="hljs-params">(String moves)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : moves.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;U&#x27;</span>) y++;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;D&#x27;</span>) y--;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;L&#x27;</span>) x++;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;R&#x27;</span>) x--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/student-attendance-record-i/description/">551. 学生出勤记录 I - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkRecord</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">abs</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lates = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                abs++;<br>                <span class="hljs-keyword">if</span>(abs &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                lates++;<br>                <span class="hljs-keyword">if</span>(lates &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> lates = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-binary-substrings/description/">696. 计数二进制子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBinarySubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        List&lt;Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s. length();<br>        <span class="hljs-keyword">while</span>(ptr &lt; n)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(ptr);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(ptr &lt; n &amp;&amp; s.charAt(ptr) == c)&#123;<br>                ++ptr;<br>                ++count;<br>            &#125;<br>            counts.add(count);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; counts.size(); ++i)&#123;<br>            ans += Math.min(counts.get(i), counts.get(i - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBinarySubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length(), last = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (ptr &lt; n) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(ptr);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (ptr &lt; n &amp;&amp; s.charAt(ptr) == c) &#123;<br>                ++ptr;<br>                ++count;<br>            &#125;<br>            ans += Math.min(count, last);<br>            last = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/capitalize-the-title/?envType=daily-question&envId=2024-03-11">2129. 将标题首字母大写 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">capitalizeTitle</span><span class="hljs-params">(String s1)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(String s : s1.split(<span class="hljs-string">&quot; &quot;</span>))&#123;<br>            <span class="hljs-keyword">if</span>(!ans.isEmpty()) ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">//左闭右开区间</span><br>                ans.append(s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase());<br>                <span class="hljs-comment">//将第二个字符（即s.charAt(1)）作为它的第首字符（即s.charAt(0)）</span><br>                s = s.substring(<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.append(s.toLowerCase());<br>        &#125;<br>         <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/description/">467. 环绕字符串中唯一的子字符串 - 力扣（LeetCode）</a></p><p>使用动态规划的方法进行操作它的递推式有点像最长递增子序列的那一个的思想自己debug一下就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSubstringInWraproundString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//dp[n]：表示以字符n结尾的最大子串的长度</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, n =s.length();<br>        <span class="hljs-keyword">while</span>(l &lt; n)&#123;<br>            r = l + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(r &lt; n &amp;&amp; isNext (s.charAt(r - <span class="hljs-number">1</span>), s.charAt(r)))&#123;<br>                r++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt; r; i++)&#123;<br>                <span class="hljs-comment">//r - i 表示当前子串的长度</span><br>                f[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = Math.max(f[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>], r - i);<br>            &#125;<br>            l = r;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; f.length;i++)&#123;<br>            res += f[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNext</span><span class="hljs-params">(<span class="hljs-type">char</span> cur, <span class="hljs-type">char</span> next)</span>&#123;<br>        <span class="hljs-keyword">if</span>(next - cur == <span class="hljs-number">1</span> || (cur == <span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; next == <span class="hljs-string">&#x27;a&#x27;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇二</title>
    <link href="/2024/03/02/str2/"/>
    <url>/2024/03/02/str2/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符"><a href="#反转字符" class="headerlink" title="反转字符"></a>反转字符</h1><p><a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            s[l] ^= s[r];<br>            s[r] ^= s[l];<br>            s[l] ^= s[r];<br>            l++;<br>            r--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II - 力扣（LeetCode）</a></p><p>每次只操作i + 2*k个数目的字符（其实是 i + k个数目的字符），直到最后不到2k个字符为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-comment">//这里对于   Math.min(i + k, n) - 1   的-1操作解释一下，因为不论是i + k还是n都代表的是一个位置（它从1开始的）</span><br>            <span class="hljs-comment">//起始位置 i 终点位置 i + k  - 1和 n - 1进行比较 </span><br>            reverseString(arr, i, Math.min(i + k, n) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>    &#125;<br>    <span class="hljs-comment">//两个字符相互交换一定是在字符数组之中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            s[l] ^= s[r];<br>            s[r] ^= s[l];<br>            s[l] ^= s[r];<br>            l++;<br>            r--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/description/">557. 反转字符串中的单词 III - 力扣（LeetCode）</a></p><ul><li>总的来说这种写法比较考验脑子尤其在于对于字符串中的单一单词逆序的处理 i - 1 + start - j（不提倡的写法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            <span class="hljs-comment">//记录空格后的第一个单词</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">//如果是第一个单词的前面有空格那就停在第一个位置上面</span><br>            <span class="hljs-comment">//这个就是为了找到(每一个单词之后的)第一个空格</span><br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>            <span class="hljs-comment">//处理   空格后的第一个单词  和单词后的第一个空格的位置单词</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> start; j &lt; i; j++) bs.append(s.charAt(i - <span class="hljs-number">1</span> + start - j));<br>            <span class="hljs-comment">//专门处理空格(为了防止有多个空格的出现)</span><br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                bs.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bs.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法可以经常练习一下双指针的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">while</span> (r &lt; n) &#123;<br>            <span class="hljs-comment">//l每次记录单词的第一个字母，r每次记录i所在那个单词后的第一个空格</span><br>            <span class="hljs-keyword">if</span> (s.charAt(r) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.substring(l, r));<br>                ret.append(tmp.reverse());<br>                ret.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>                l = r + <span class="hljs-number">1</span>;<br>            &#125;<br>            r++;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.substring(l, r));<br>        ret.append(tmp.reverse());<br>        <span class="hljs-keyword">return</span> ret.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><p>学习新API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 除去开头和末尾的空白字符</span><br>        s = s.trim();<br>        <span class="hljs-comment">// 正则匹配连续的空白字符作为分隔符分割</span><br>        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="hljs-string">&quot;\\s+&quot;</span>));<br>        Collections.reverse(wordList);<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, wordList);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">strLen</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxEnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//终点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//长度</span><br>        <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[strLen][strLen];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; r &lt; strLen; r++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; r; l++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="hljs-number">2</span> || f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>])) &#123;<br>                    f[l][r] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                        maxLen = r - l + <span class="hljs-number">1</span>;<br>                        maxStart = l;<br>                        maxEnd = r;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxStart, maxEnd + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> s.substring(j, i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (ss.equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(ss).reverse().toString())) &#123;<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年3月每日一题</title>
    <link href="/2024/03/01/3%E6%9C%88/"/>
    <url>/2024/03/01/3%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3 - 1"></a>3 - 1</h2><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/description/?envType=daily-question&envId=2024-03-01">2369. 检查数组是否存在有效划分 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">2</span>] &amp;&amp; validTwo(nums[i - <span class="hljs-number">2</span>], nums[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">3</span>) &#123;<br>                dp[i] = dp[i] || (dp[i - <span class="hljs-number">3</span>] &amp;&amp; validThree(nums[i - <span class="hljs-number">3</span>], nums[i - <span class="hljs-number">2</span>], nums[i - <span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>        <span class="hljs-keyword">return</span> num1 == num2;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validThree</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">int</span> num3)</span> &#123;<br>        <span class="hljs-keyword">return</span> (num1 == num2 &amp;&amp; num1 == num3) || (num1 + <span class="hljs-number">1</span> == num2 &amp;&amp; num2 + <span class="hljs-number">1</span> == num3);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-2"><a href="#3-2" class="headerlink" title="3 - 2"></a>3 - 2</h2><p><a href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/description/?envType=daily-question&envId=2024-03-02">2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reachableNodes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span>[] restricted)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] isrestricted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : restricted) &#123;<br>            isrestricted[x] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        List&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            g[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] v : edges) &#123;<br>            g[v[<span class="hljs-number">0</span>]].add(v[<span class="hljs-number">1</span>]);<br>            g[v[<span class="hljs-number">1</span>]].add(v[<span class="hljs-number">0</span>]);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, isrestricted, g);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f, <span class="hljs-type">boolean</span>[] isrestricted, List&lt;Integer&gt;[] g)</span> &#123;<br>        cnt++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : g[x]) &#123;<br>            <span class="hljs-keyword">if</span> (y != f &amp;&amp; !isrestricted[y]) &#123;<br>                dfs(y, x, isrestricted, g);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3"><a href="#3-3" class="headerlink" title="3 - 3"></a>3 - 3</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/?envType=daily-question&envId=2024-03-03">225. 用队列实现栈 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue1;<br>    Queue&lt;Integer&gt; queue2;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue2.offer(x);<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            queue2.offer(queue1.poll());<br>        &#125;<br>        Queue&lt;Integer&gt; temp = queue1;<br>        queue1 = queue2;<br>        queue2 = temp;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue1.poll();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue1.peek();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue1.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4"><a href="#3-4" class="headerlink" title="3 - 4"></a>3 - 4</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/submissions/507273961/?envType=daily-question&envId=2024-03-04">232. 用栈实现队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        inStack.push(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in2out</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5"><a href="#3-5" class="headerlink" title="3 - 5"></a>3 - 5</h2><p><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/description/?envType=daily-question&envId=2024-03-05">1976. 到达目的地的方案数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] roads)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            e[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] road : roads) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> road[<span class="hljs-number">0</span>], y = road[<span class="hljs-number">1</span>], t = road[<span class="hljs-number">2</span>];<br>            e[x].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;y, t&#125;);<br>            e[y].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, t&#125;);<br>        &#125;<br>        <span class="hljs-type">long</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        Arrays.fill(dis, Long.MAX_VALUE);<br>        <span class="hljs-type">int</span>[] ways = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        PriorityQueue&lt;<span class="hljs-type">long</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">long</span>[]&gt;((a, b) -&gt; Long.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br>        pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        ways[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            <span class="hljs-type">long</span>[] arr = pq.poll();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) arr[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (t &gt; dis[u]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] next : e[u]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> next[<span class="hljs-number">0</span>], w = next[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (t + w &lt; dis[v]) &#123;<br>                    dis[v] = t + w;<br>                    ways[v] = ways[u];<br>                    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[]&#123;t + w, v&#125;);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t + w == dis[v]) &#123;<br>                    ways[v] = (ways[u] + ways[v]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ways[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6"><a href="#3-6" class="headerlink" title="3 - 6"></a>3 - 6</h2><p><a href="https://leetcode.cn/problems/find-the-k-or-of-an-array/submissions/508261976/?envType=daily-question&envId=2024-03-06">2917. 找出数组中的 K-or 值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKOr</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">31</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>                cnt1 += x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt1 &gt;= k) &#123;<br>                ans |= <span class="hljs-number">1</span> &lt;&lt; i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-7"><a href="#3-7" class="headerlink" title="3 - 7"></a>3 - 7</h2><p><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/?envType=daily-question&envId=2024-03-07">2575. 找出字符串的可整除数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] divisibilityArray(String word, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">char</span>[] s = word.toCharArray();<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; s.length; i++)&#123;<br>            x = (x*<span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)) % m;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) ans[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8"><a href="#3-8" class="headerlink" title="3 - 8"></a>3 - 8</h2><p><a href="https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/description/?envType=daily-question&envId=2024-03-08">2834. 找出美丽数组的最小和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumPossibleSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Math.min(k / <span class="hljs-number">2</span>, n);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((m * (m + <span class="hljs-number">1</span>) + (n - m - <span class="hljs-number">1</span> + k * <span class="hljs-number">2</span>) * (n - m)) / <span class="hljs-number">2</span> % <span class="hljs-number">1_000_000_007</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-9"><a href="#3-9" class="headerlink" title="3 - 9"></a>3 - 9</h2><p><a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/description/?envType=daily-question&envId=2024-03-09">2386. 找出数组的第 K 大和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">kSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                sum += nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[i] = -nums[i];<br>            &#125;<br>            right += nums[i];<br>        &#125;<br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123; <span class="hljs-comment">// 开区间二分，原理见【前置知识】</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            cnt = k - <span class="hljs-number">1</span>; <span class="hljs-comment">// 空子序列算一个</span><br>            dfs(<span class="hljs-number">0</span>, mid, nums);<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 找到 k 个元素和不超过 mid 的子序列</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - right;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cnt;<br><br>    <span class="hljs-comment">// 反向递归，增加改成减少，这样可以少传一些参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">long</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span> || i == nums.length || s &lt; nums[i]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cnt--;<br>        dfs(i + <span class="hljs-number">1</span>, s - nums[i], nums); <span class="hljs-comment">// 选</span><br>        dfs(i + <span class="hljs-number">1</span>, s, nums); <span class="hljs-comment">// 不选</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-10"><a href="#3-10" class="headerlink" title="3 - 10*"></a>3 - 10*</h2><p><a href="https://leetcode.cn/problems/bulls-and-cows/description/?envType=daily-question&envId=2024-03-10">299. 猜数字游戏 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHint</span><span class="hljs-params">(String secret, String guess)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> secret.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] cnt1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>], cnt2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> secret.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>, c2= guess.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                a++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt1[c1]++;<br>                cnt2[c2]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) b += Math.min(cnt1[i], cnt2[i]);<br>        <span class="hljs-keyword">return</span> a + <span class="hljs-string">&quot;A&quot;</span> + b + <span class="hljs-string">&quot;B&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-11"><a href="#3-11" class="headerlink" title="3 - 11"></a>3 - 11</h2><p><a href="https://leetcode.cn/problems/capitalize-the-title/?envType=daily-question&envId=2024-03-11">2129. 将标题首字母大写 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">capitalizeTitle</span><span class="hljs-params">(String s1)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(String s : s1.split(<span class="hljs-string">&quot; &quot;</span>))&#123;<br>            <span class="hljs-keyword">if</span>(!ans.isEmpty()) ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">2</span>)&#123;<br>                ans.append(s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase());<br>                s = s.substring(<span class="hljs-number">1</span>);<br>            &#125;<br>            ans.append(s.toLowerCase());<br>        &#125;<br>         <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-12"><a href="#3-12" class="headerlink" title="3 - 12"></a>3 - 12</h2><p><a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/description/?envType=daily-question&envId=2024-03-12">1261. 在受污染的二叉树中查找元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FindElements</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FindElements</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.contains(target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        s.add(val);<br>        dfs(node.left, val * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        dfs(node.right, val * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-13"><a href="#3-13" class="headerlink" title="3 - 13"></a>3 - 13</h2><p><a href="https://leetcode.cn/problems/maximum-odd-binary-number/description/?envType=daily-question&envId=2024-03-13">2864. 最大二进制奇数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">maximumOddBinaryNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) cnt += s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt - <span class="hljs-number">1</span>; i++)&#123;<br>            sb.append(<span class="hljs-number">1</span>);<br>        &#125; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - cnt; i++)&#123;<br>            sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-14"><a href="#3-14" class="headerlink" title="3 - 14"></a>3 - 14</h2><p><a href="https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/description/?envType=daily-question&envId=2024-03-14">2789. 合并后数组中的最大元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxArrayValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[nums.length - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            sum = nums[i] &lt;= sum ? nums[i] + sum : nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-15"><a href="#3-15" class="headerlink" title="3 - 15"></a>3 - 15</h2><p><a href="https://leetcode.cn/problems/selling-pieces-of-wood/solutions/?envType=daily-question&envId=2024-03-15">2312. 卖木头块 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sellingWood</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[][] pr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : prices) &#123;<br>            pr[p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]] = p[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-type">long</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                f[i][j] = pr[i][j];<br>                <span class="hljs-comment">// 垂直切割</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt; j; k++) f[i][j] = Math.max(f[i][j], f[i][k] + f[i][j - k]); <br>                <span class="hljs-comment">// 水平切割</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt; i; k++) f[i][j] = Math.max(f[i][j], f[k][j] + f[i - k][j]); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-16"><a href="#3-16" class="headerlink" title="3 - 16"></a>3 - 16</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/description/?envType=daily-question&envId=2024-03-16">2684. 矩阵中移动的最大次数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>            dfs(i, <span class="hljs-number">0</span>, grid); <span class="hljs-comment">// 从第一列的任一单元格出发</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        ans = Math.max(ans, j);<br>        <span class="hljs-keyword">if</span> (ans == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// ans 已达到最大值</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 向右上/右/右下走一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.max(i - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); k &lt; Math.min(i + <span class="hljs-number">2</span>, grid.length); k++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[k][j + <span class="hljs-number">1</span>] &gt; grid[i][j]) &#123;<br>                dfs(k, j + <span class="hljs-number">1</span>, grid);<br>            &#125;<br>        &#125;<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-17"><a href="#3-17" class="headerlink" title="3 - 17"></a>3 - 17</h2><p><a href="https://leetcode.cn/problems/minimum-height-trees/?envType=daily-question&envId=2024-03-17">310. 最小高度树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">20010</span>, M = N * <span class="hljs-number">2</span>, idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] he = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M], ne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br>    <span class="hljs-type">int</span>[] f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], f2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        e[idx] = b;<br>        ne[idx] = he[a];<br>        he[a] = idx++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        Arrays.fill(he, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], b = e[<span class="hljs-number">1</span>];<br>            add(a, b); add(b, a);<br>        &#125;<br>        dfs1(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        dfs2(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(f1[i], g[i]);<br>            <span class="hljs-keyword">if</span> (cur &lt; min) &#123;<br>                min = cur;<br>                ans.clear();<br>                ans.add(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == min) &#123;<br>                ans.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> he[u]; i != -<span class="hljs-number">1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            <span class="hljs-keyword">if</span> (j == fa) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> dfs1(j, u) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (sub &gt; f1[u]) &#123;<br>                f2[u] = f1[u];<br>                f1[u] = sub;<br>                p[u] = j;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sub &gt; f2[u]) &#123;<br>                f2[u] = sub;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f1[u];<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> he[u]; i != -<span class="hljs-number">1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e[i];<br>            <span class="hljs-keyword">if</span> (j == fa) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (p[u] != j) g[j] = Math.max(g[j], f1[u] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> g[j] = Math.max(g[j], f2[u] + <span class="hljs-number">1</span>);<br>            g[j] = Math.max(g[j], g[u] + <span class="hljs-number">1</span>);<br>            dfs2(j, u);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-18"><a href="#3-18" class="headerlink" title="3 - 18"></a>3 - 18</h2><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/submissions/513262078/?envType=daily-question&envId=2024-03-18">303. 区域和检索 - 数组不可变 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = nums.length;<br>        sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)  sum[i + <span class="hljs-number">1</span>] = sum[i] + nums[i];<br>    &#125; <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> sum[right + <span class="hljs-number">1</span>] - sum[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-19"><a href="#3-19" class="headerlink" title="3 - 19"></a>3 - 19</h2><p><a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/description/?envType=daily-question&envId=2024-03-19">1793. 好子数组的最大分数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> k, r = k, n = nums.length, res = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义左右边界l r，最大可能分数res</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123; <br>            <span class="hljs-keyword">while</span>(r &lt; n &amp;&amp; nums[r] &gt;= nums[k]) r++; <span class="hljs-comment">//向右寻找以nums[k]为最小值的好子数组</span><br>            <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[l] &gt;= nums[k]) l--; <span class="hljs-comment">//向左寻找以nums[k]为最小值的好子数组</span><br>            res = Math.max(res, (r - l - <span class="hljs-number">1</span>) * nums[k]);  <span class="hljs-comment">//更新最大可能分数</span><br>            <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span> &amp;&amp; r == n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//遍历完数组，直接退出循环</span><br>            <span class="hljs-keyword">if</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n) nums[k] = Math.max(nums[l], nums[r]); <span class="hljs-comment">//更新nums[k] 为左右边界中的较大者</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span>) nums[k] = nums[r]; <span class="hljs-comment">//左边遍历完了，更新nums[k]为右边界</span><br>            <span class="hljs-keyword">else</span> nums[k] = nums[l]; <span class="hljs-comment">//右边遍历完了，更新nums[k]为左边界</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-20"><a href="#3-20" class="headerlink" title="3 - 20"></a>3 - 20</h2><p><a href="https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/description/?envType=daily-question&envId=2024-03-20">1969. 数组元素的最小非零乘积 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minNonZeroProduct</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000000</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> fastPow(<span class="hljs-number">2</span>, p, mod) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) <span class="hljs-number">1</span> &lt;&lt; (p - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(fastPow(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>, mod)*x % mod);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">fastPow</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> mod)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) res = res*x%mod;<br>            x = x * x %mod; <br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-21"><a href="#3-21" class="headerlink" title="3 - 21"></a>3 - 21</h2><p><a href="https://leetcode.cn/problems/frequency-tracker/description/?envType=daily-question&envId=2024-03-21">2671. 频率跟踪器 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrequencyTracker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// number 的出现次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// number 的出现次数的出现次数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FrequencyTracker</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> number, <span class="hljs-type">int</span> delta)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cnt.merge(number, delta, Integer::sum);<br>        freq.merge(c - delta, -<span class="hljs-number">1</span>, Integer::sum); <span class="hljs-comment">// 去掉一个旧的 cnt[number]</span><br>        freq.merge(c, <span class="hljs-number">1</span>, Integer::sum); <span class="hljs-comment">// 添加一个新的 cnt[number]</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        update(number, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteOne</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cnt.getOrDefault(number, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            update(number, -<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasFrequency</span><span class="hljs-params">(<span class="hljs-type">int</span> frequency)</span> &#123;<br>        <span class="hljs-keyword">return</span> freq.getOrDefault(frequency, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>; <span class="hljs-comment">// 至少有一个 number 的出现次数恰好为 frequency</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-22"><a href="#3-22" class="headerlink" title="3 - 22"></a>3 - 22</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/?envType=daily-question&envId=2024-03-22">2617. 网格图中最少访问的格子数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumVisitedCells</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] colStacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n]; <span class="hljs-comment">// 每列的单调栈，为了能二分用 ArrayList</span><br>        Arrays.setAll(colStacks, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;());<br>        List&lt;<span class="hljs-type">int</span>[]&gt; rowSt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 行单调栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            rowSt.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> grid[i][j];<br>                List&lt;<span class="hljs-type">int</span>[]&gt; colSt = colStacks[j];<br>                mn = i &lt; m - <span class="hljs-number">1</span> || j &lt; n - <span class="hljs-number">1</span> ? Integer.MAX_VALUE : <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (g &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 可以向右/向下跳</span><br>                    <span class="hljs-comment">// 在单调栈上二分查找最优转移来源</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> search(rowSt, j + g);<br>                    <span class="hljs-keyword">if</span> (k &lt; rowSt.size()) &#123;<br>                        mn = rowSt.get(k)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    k = search(colSt, i + g);<br>                    <span class="hljs-keyword">if</span> (k &lt; colSt.size()) &#123;<br>                        mn = Math.min(mn, colSt.get(k)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (mn &lt; Integer.MAX_VALUE) &#123;<br>                    <span class="hljs-comment">// 插入单调栈</span><br>                    <span class="hljs-keyword">while</span> (!rowSt.isEmpty() &amp;&amp; mn &lt;= rowSt.get(rowSt.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]) &#123;<br>                        rowSt.remove(rowSt.size() - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    rowSt.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;mn, j&#125;);<br>                    <span class="hljs-keyword">while</span> (!colSt.isEmpty() &amp;&amp; mn &lt;= colSt.get(colSt.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]) &#123;<br>                        colSt.remove(colSt.size() - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    colSt.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;mn, i&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mn &lt; Integer.MAX_VALUE ? mn : -<span class="hljs-number">1</span>; <span class="hljs-comment">// 最后一个算出的 mn 就是 f[0][0]</span><br>    &#125;<br><br>    <span class="hljs-comment">// 开区间二分，见 https://www.bilibili.com/video/BV1AP41137w7/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>[]&gt; st, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = st.size(); <span class="hljs-comment">// 开区间 (left, right)</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123; <span class="hljs-comment">// 区间不为空</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (st.get(mid)[<span class="hljs-number">1</span>] &lt;= target) &#123;<br>                right = mid; <span class="hljs-comment">// 范围缩小到 (left, mid)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid; <span class="hljs-comment">// 范围缩小到 (mid, right)</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-23"><a href="#3-23" class="headerlink" title="3 - 23"></a>3 - 23</h2><p><a href="https://leetcode.cn/problems/count-distinct-numbers-on-board/description/?envType=daily-question&envId=2024-03-23">2549. 统计桌面上的不同数字 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        nums[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[x] == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>                    <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">1</span>) &#123;<br>                        nums[i] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(nums).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-24"><a href="#3-24" class="headerlink" title="3 - 24"></a>3 - 24</h2><p><a href="https://leetcode.cn/problems/coin-change/description/?envType=daily-question&envId=2024-03-24">322. 零钱兑换 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(f,<span class="hljs-number">65534</span>);<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; j++) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(j &gt;= coins[i])<br>                &#123;<br>                    f[j] = Math.min(f[j] , f[j - coins[i]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[amount] == <span class="hljs-number">65534</span> ? -<span class="hljs-number">1</span> : f[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-25"><a href="#2-25" class="headerlink" title="2 - 25"></a>2 - 25</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/description/?envType=daily-question&envId=2024-03-25">518. 零钱兑换 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; coins.length ; i++)<span class="hljs-comment">/*遍历物品*/</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i] ; j &lt;= amount ; j++)<span class="hljs-comment">/*遍历背包*/</span><br>            &#123;<br>                f[j] += f[j - coins[i]];<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> f[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-26"><a href="#3-26" class="headerlink" title="3 - 26"></a>3 - 26</h2><p><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/description/?envType=daily-question&envId=2024-03-26">2642. 设计可以求最短路径的图类 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止更新最短路时加法溢出</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[][] g;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n]; <span class="hljs-comment">// 邻接矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : g) &#123;<br>            Arrays.fill(row, INF);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            addEdge(e); <span class="hljs-comment">// 添加一条边（题目保证没有重边）</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] e)</span> &#123;<br>        g[e[<span class="hljs-number">0</span>]][e[<span class="hljs-number">1</span>]] = e[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 添加一条边（题目保证这条边之前不存在）</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPath</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length;<br>        <span class="hljs-type">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 从 start 出发，到各个点的最短路，如果不存在则为无穷大</span><br>        Arrays.fill(dis, INF);<br>        dis[start] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; (x &lt; <span class="hljs-number">0</span> || dis[i] &lt; dis[x])) &#123;<br>                    x = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || dis[x] == INF) &#123;<span class="hljs-comment">// 所有从 start 能到达的点都被更新了</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x == end) &#123;<span class="hljs-comment">// 找到终点，提前退出</span><br>                <span class="hljs-keyword">return</span> dis[x];<br>            &#125;<br>            vis[x] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记，在后续的循环中无需反复更新 x 到其余点的最短路长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>                dis[y] = Math.min(dis[y], dis[x] + g[x][y]); <span class="hljs-comment">// 更新最短路长度</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-27"><a href="#3-27" class="headerlink" title="3 - 27*"></a>3 - 27*</h2><p><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/description/?envType=daily-question&envId=2024-03-27">2580. 统计将重叠区间合并成组的方案数 - 力扣（LeetCode）</a></p><p>此题目可以视为，如果两个集合之间有交集，那么就可以视为是一个集合，有一点像当初做过的那道“甲板上的战舰”，且它k集合（归类之后）都可以在<code>A</code>或者<code>B</code>两个组进行选择所以它组合的方案有2^k个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges)</span> &#123;<br>        <span class="hljs-comment">//根据第一个元素的大小进行排序</span><br>        Arrays.sort(ranges, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxR</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : ranges) &#123;<br>            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] &gt; maxR) &#123; <span class="hljs-comment">// 无法合并</span><br>                ans = ans * <span class="hljs-number">2</span> % <span class="hljs-number">1_000_000_007</span>; <span class="hljs-comment">// 新区间</span><br>            &#125;<br>            maxR = Math.max(maxR, p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 合并</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-28"><a href="#3-28" class="headerlink" title="3 - 28"></a>3 - 28</h2><p><a href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/submissions/517626407/?envType=daily-question&envId=2024-03-28">1997. 访问完所有房间的第一 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstDayBeenInAllRooms</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nextVisit)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nextVisit.length;<br>        <span class="hljs-type">long</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nextVisit[i];<br>            s[i + <span class="hljs-number">1</span>] = (s[i] * <span class="hljs-number">2</span> - s[j] + <span class="hljs-number">2</span> + MOD) % MOD; <span class="hljs-comment">// + MOD 避免算出负数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) s[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-29"><a href="#3-29" class="headerlink" title="3 - 29"></a>3 - 29</h2><p><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/?envType=daily-question&envId=2024-03-29">2908. 元素和最小的山形三元组 I - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] &lt; nums[j] &amp;&amp; nums[k] &lt; nums[j]) &#123;<br>                        res = Math.min(res, nums[i] + nums[j] + nums[k]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &lt; <span class="hljs-number">1000</span> ? res : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-30"><a href="#3-30" class="headerlink" title="3 - 30*"></a>3 - 30*</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/?envType=daily-question&envId=2024-03-30">2952. 需要添加的硬币的最小数量 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumAddedCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(coins);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> coins.length, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x &lt;= target)&#123;<br>            <span class="hljs-keyword">if</span>(index &lt; length &amp;&amp; coins[index] &lt;= x)&#123;<br>                x += coins[index];<br>                index++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                x *= <span class="hljs-number">2</span>;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-31"><a href="#3-31" class="headerlink" title="3 - 31"></a>3 - 31</h2><p><a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/description/?envType=daily-question&envId=2024-03-31">331. 验证二叉树的前序序列化 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSerialization</span><span class="hljs-params">(String preorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        stack.push(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (preorder.charAt(i) == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preorder.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>) &#123;<br>                    stack.push(top);<br>                &#125;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 读一个数字</span><br>                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; preorder.charAt(i) != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                    i++;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>) &#123;<br>                    stack.push(top);<br>                &#125;<br>                stack.push(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2024年3月每日一题结束</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串篇一</title>
    <link href="/2024/02/29/str1/"/>
    <url>/2024/02/29/str1/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><a href="https://leetcode.cn/problems/detect-capital/">520. 检测大写字母 - 力扣（LeetCode）</a></p><img src="https://cdn.jsdelivr.net/gh/kyclnx/image/20240229131322.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;中&#x27;</span>;<br><span class="hljs-keyword">if</span>(Character.isLowerCase(a)||Character.isUpperCase(a)) &#123;<br>System.out.println(<span class="hljs-string">&quot;字符a是字母！&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;字符a不是字母！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">detectCapitalUse</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : word.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(Character.isUpperCase(c)) num++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (num == n || num == <span class="hljs-number">0</span> || (num == <span class="hljs-number">1</span> &amp;&amp; Character.isUpperCase(word.charAt(<span class="hljs-number">0</span>))));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/valid-palindrome/description/">125. 验证回文串 - 力扣（LeetCode）</a></p><img src="https://cdn.jsdelivr.net/gh/kyclnx/image/20240229172151.png" style="zoom:80%;" /><p>很难想得到Character.isLetterOrDight()这个API，所以自己写一个函数进行判断，只需要记得</p><p><strong>Character.isLowerCase()   Character.toLowerCase()   Character.isUpperCase()    Character.toUpperCase()</strong></p><p>判断及筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(isValid(c)) sb1.append(Character.toLowerCase(c));<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(sb1).reverse();<br>        System.out.println(sb1.toString());<br>        <span class="hljs-keyword">return</span> sb1.toString().equals(sb2.toString());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span> b)</span>&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Character.toLowerCase(b);<br>        <span class="hljs-keyword">return</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">bs1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(Character.isLetterOrDigit(c))&#123;<br>                bs1.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> bs1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ,right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(Character.toLowerCase(bs1.charAt(left))  != Character.toLowerCase(bs1.charAt(right)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在原字符串上直接判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] c = s.toLowerCase().toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">while</span>(!isValid(c[l]) &amp;&amp; l &lt; r)&#123;<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!isValid(c[r]) &amp;&amp; l &lt; r)&#123;<br>                --r;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c[l] != c[r]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-common-prefix/description/">14. 最长公共前缀 - 力扣（LeetCode）</a></p><p>横向扫描 </p><p>横向扫描是一种惯性思维</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || Objects.equals(strs[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        prev = LCP(prev, strs[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">LCP</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(str2.length(), str1.length());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count &lt; len &amp;&amp; str1.charAt(count) == str2.charAt(count)) &#123;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str1.substring(<span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>纵向扫描</p><p>纵向只有两种异常的情况会停止扫描</p><p>1、如果扫描的位置是数组中元素的最后一个字符</p><p>2、扫描的字符和当前**strs[0].charAt(i) **的字符不匹配。</p><p>有一种特殊情况就是**strs[0]**扫描到了最后，那就直接返回strs[0]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span>(strs == <span class="hljs-literal">null</span> || strs[<span class="hljs-number">0</span>].length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//纵向扫描</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].charAt(i);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == strs[j].length() || c != strs[j].charAt(i))&#123;<br>                    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分查找(暂时不会)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLength</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            minLength = Math.min(minLength, str.length());<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, high = minLength;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-keyword">if</span> (isCommonPrefix(strs, mid)) &#123;<br>                low = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, low);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCommonPrefix</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str0</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strs[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-segments-in-a-string/description/">434. 字符串中的单词数 - 力扣（LeetCode）</a></p><p><img src="https://s2.loli.net/2024/03/02/2AFdvbDPf5ZHiCY.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSegments</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n ; i++)&#123;<br>            <span class="hljs-keyword">if</span>((i == <span class="hljs-number">0</span> || s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/length-of-last-word/description/">58. 最后一个单词的长度 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLastWord</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这一步是为了防止类似&quot;Hello World   &quot;的情况的出现</span><br>        <span class="hljs-keyword">while</span>(s.charAt(n) == <span class="hljs-string">&#x27; &#x27;</span>) n--;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(n) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            n--;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章节</title>
    <link href="/2024/02/28/cn_%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2024/02/28/cn_%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-物理层"><a href="#第2章-物理层" class="headerlink" title="第2章 物理层"></a>第2章 物理层</h1><p>本章节最重要的内容是：</p><p>（1）物理层的任务。</p><p>（2）几种常用的信道复用技术。</p><p>（3）几种常见的带宽接入技术，重点是FTTX。 </p><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是具体的传输媒体。现有计算机网络传输媒体种类繁多，通信手段也有许多不同的方式。物理层的作用正是要尽可能地屏蔽这些传输媒体和通信手段的差异，使得物理层上面的数据链路层感觉不到这些差异，这样就可以使得数据链路层只考虑如何完成本层的协议和服务，而不必考虑具体的传输媒体和通信手段是什么。</p><p>数据在计算机内部采用并行传输的方式，但是在数据通信线路（传输媒体）上的传输方式一般都是串行传输（经济上考虑），即逐个比特按照时间顺序传输，因此物理层还要完成传输方式的转换。</p><p>具体的物理层协议种类较多。这是因为物理连接方式很多（点对点、多点连接、广播连接），而传输媒体的种类也非常多（双绞线、同轴电缆、光缆）。</p><h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><h3 id="2-2-1-数据通信的系统模型"><a href="#2-2-1-数据通信的系统模型" class="headerlink" title="2.2.1 数据通信的系统模型"></a>2.2.1 数据通信的系统模型</h3><p>如图所示，一个数据通信系统可划分为三大部分，即<strong>源系统</strong>(或发送端、发送方)、<strong>传输系统</strong>(或传输网络)和<strong>目的系统</strong>(或接收端、接收方)。</p><p><img src="https://cdn.jsdelivr.net/gh/kyclnx/image/20240229155138.png"></p><p>根据信号中代表消息的参数取值方式不同，信号可分为以下两大类：</p><p>（1）<strong>模拟信号</strong>，或<strong>连续信号</strong>—代表消息的参数取值是连续的。如图中用户家中的调制解调器到电话端局之间的用户线上传输的就是模拟信号。</p><p>（2）<strong>数字信号</strong>，或<strong>离散信号</strong>—代表消息的参数取值是离散的。如图用户家中的计算机到调制解调器之间或在电话网中继线上传送的就是数字信号。在使用时间域(或简称为时域)的波形表示数字值号时，代表不同离散数值的基本波形就称为<em><strong>码元</strong></em>，在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一.种代表1状态。</p><h3 id="2-2-2-有关信道的几个基本概念"><a href="#2-2-2-有关信道的几个基本概念" class="headerlink" title="2.2.2 有关信道的几个基本概念"></a>2.2.2 有关信道的几个基本概念</h3><p><strong>（1）单向通信</strong>：又称为单工通信，即只能有一个方向通信而没有反方向的交互。无线广播或者有线广播以及电视广播就是属于这种类型。</p><p><strong>（2）双向交替通信</strong>：又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送信息（当然也就不能同时接收）。这种通信方式是一方发送，另一方接收，过一段时间后可以再反过来。</p><p><strong>（3）双向同时通信</strong>：又称为全双工通信，即通信双方可以同时发送和接收消息。</p><p>单向通信只需要一条信道，而双向交替通信或双向同时通信都需要两条信道（每个方向各一条）。双向同时通信的效率最高。</p><p>来自信源的信号常称为<em><strong>基带信号</strong></em>(即基本频带信号)。像计算机输出的代表各种文字野图像文件的数据信号都属于基带信号。基带信号往往包含较多的低频分量，其至有直流分重，而许乡信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行***调制(modulation)***。</p><p>调制可分为两大类。一类是仅仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。这类调制称为<em><strong>基带调制</strong></em>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为<em><strong>编码(coding)<em><strong>。另一类调制则需要使用</strong></em>载波(carier)<em><strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为</strong></em>带通信号</strong></em>(即仅在一段频率范围内能够通过信道)，而使用载波的调制称为<em><strong>带通调制</strong></em>。</p><p><strong>（1）常用的编码方式</strong></p><img src="https://cdn.jsdelivr.net/gh/kyclnx/image/20240229164231.png" style="zoom:67%;" /><ul><li><p><strong>不归零制</strong>: 正电平代表1,负电平代表0。</p></li><li><p><strong>归零制</strong>: 正脉冲代表1,负脉冲代表0。</p></li><li><p><strong>曼彻斯特编码</strong>: 位周期中心的向上跳变代表0,位周期中心的向下跳变代表1。但也可反过来定义。</p></li><li><p><strong>差分曼彻斯特编码</strong>: 在每一位的中心处始终都有跳变。位开始边界有跳变代表0,而位开始边界没有跳变代表1。</p></li></ul><p>从信号波形中可以看出，曼彻斯特(Manchester)编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率(这叫作没有自同步能力)，而曼彻斯特编码具有自同步能力。</p><p><strong>(2)基本的带通调制方法</strong></p><img src="https://cdn.jsdelivr.net/gh/kyclnx/image/20240229164643.png" style="zoom: 67%;" /><ul><li><p>**调幅(AM)**，即载波的振幅随基带数字信号而变化。例如，0或1分别对应于无载波或有载波输出。</p></li><li><p><strong>调频</strong>(FM),即载波的频率随基带数字信号而变化。例如，0或1分别对应于频率fr或f2。</p></li><li><p><strong>调相</strong>(PM)，即载波的初始相位随基带数字信号而变化。例如，0或1分别对应于相位0度或180度。</p></li></ul><h3 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h3><p>码元的传输速率越高、信号传输的距离越远、噪声干扰越大或媒体传输质量越差，在接收端波形失真就越严重。</p><p><strong>（1）信道能够通过的频率范围</strong></p><p>在接收端收到的波形失去了码元的清晰界限。这种现象称为<strong>码间串扰</strong></p><p><strong>奈氏准则</strong>：在宽带为W的低通信道中，若不考虑噪声影响，码元的传输速率最高速率是2W，传输超过此上限，就会出现严重的码间串扰问题，使得接收端对码元的识别成为不可能。</p><p>信噪比就是信号的平均功率和噪声的平均功率之比，即：S&#x2F;N。</p><p>香农公式指出：信道的极限传输速率C是: C &#x3D; W log2(1+S&#x2F;N) bit&#x2F;s</p><p>香农公式表明，信道的带宽或者信道中的信噪比越大，信息的极限传输速率就越高。</p><h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><p><strong>传输媒体</strong>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>(这里的“导引型”的英文就是guided, 也可译为“导向传输媒体”)。在导引型传输媒体中，电磁波被导引沿着固体媒体(铜线或光纤)传播:而非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。</p><h3 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1  导引型传输媒体"></a>2.3.1  导引型传输媒体</h3><ol><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ol><h3 id="2-3-1-非导引型传输媒体"><a href="#2-3-1-非导引型传输媒体" class="headerlink" title="2.3.1 非导引型传输媒体"></a>2.3.1 非导引型传输媒体</h3><p>无线传输</p><h2 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h2><h3 id="2-4-1-频分复用、时分复用、统计时分复用"><a href="#2-4-1-频分复用、时分复用、统计时分复用" class="headerlink" title="2.4.1 频分复用、时分复用、统计时分复用"></a>2.4.1 频分复用、时分复用、统计时分复用</h3><img src="https://s2.loli.net/2024/03/02/oPmB149JbgOerTy.png" style="zoom:80%;" /><p>最基本的复用就是<strong>频分复用FDM</strong>和<strong>时分复用TDM</strong>，频分复用的概念是这样的，有n路信号在一个信道中传送。可以使用调制的方法，将各路信号搬移到适当的频率，使得彼此不会产生干扰如图2-16(a)所示。 各路信号就在自己所分配到的信道中传送。可见频分复用的各路信号在同样的时间占用不同的带宽资源(请注意，这里的“带宽”是频率带宽而不是数据的发达速率)。而时分复用则是将时间划分为一段段等长的时分复用帧(即TDM帧)。每一路信号在每一个TDM帧中占用固定序号的时隙。为简单起见，在图2-16(b)中只画出了4路信号A,B,C和D,每一路信号所占用的时隙周期性地出现(其周期就是TDM帧的长度)。因此TDM信号也称为<strong>等时</strong>(isochronous)信号。可以看出，时分复用的所有用户是在不同的时间占用同样的频带宽度。这两种复用方法的优点是技术比较成熟，但缺点是不够灵活。时分复用则更有利于数字信号的传输。</p><img src="https://s2.loli.net/2024/03/02/Rb3AyJUtZiDgIVe.png" style="zoom:80%;" /><p>在进行通信的时候，复用器和分用器总是成对的使用。在复用器和分用器之间的是用户共享的高速信道。分用器的作用和复用器的相反，它将高速信道传送过来的数据进行分用，分别交付到相应的用户。</p><h3 id="2-4-2-波分复用"><a href="#2-4-2-波分复用" class="headerlink" title="2.4.2 波分复用"></a>2.4.2 波分复用</h3>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章节</title>
    <link href="/2024/02/18/cn_%E7%AE%80%E8%BF%B0/"/>
    <url>/2024/02/18/cn_%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>本章节的重点是互联网边缘部分和核心部分的作用，其中包含分组交换的概念。<br>计算机网络的性能指标<br>计算机网络的分层次体系的结构，其中包含协议和服务的概念。</p><h1 id="第1章概述"><a href="#第1章概述" class="headerlink" title="第1章概述"></a>第1章概述</h1><h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><p>三类网络，<strong>电信网络</strong>（电话、电报、传真等服务），<strong>有线电视网</strong>（向用户传递各种电视节目），<strong>计算机网络</strong>（在计算机之间传递各种文件）</p><p>互联网之所以能够向用户提供许多服务，就是因为互联网具有两个最重要的基本特点，即<strong>连通性</strong>和<strong>共享</strong>。</p><ul><li><strong>连通性</strong>就是互联网使上网用户之间不管相距离多远都可以便捷非常经济地交换各种信息，好像这些用户终端都彼此相互联通一样。这与使用传统电信网络有着很大地区别。传统地电信网络向用户提供地最重要地服务就是人与人之间的电话通信，因此电信网也具有连通型这个特点，但使用用电信网的用户需要支付一笔高昂的费用，特别是长距离的越洋通信。</li><li><strong>共享性</strong>就是指资源共享（信息共享、软件共享、硬件共享）。</li></ul><h2 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h2><h3 id="1-2-1-网络的网络"><a href="#1-2-1-网络的网络" class="headerlink" title="1.2.1 网络的网络"></a>1.2.1 网络的网络</h3><p>计算机网络是由若干节点和连接这些节点的链路组成，网络中的节点可以是集线器、计算机、交换机、或者路由器等。</p><p><strong>网络将许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络连接的计算机通常称为主机</strong></p><h3 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 互联网基础结构发展的三个阶段</h3><ul><li>第一阶段是从单个网络ARPANET向互联网发展的过程。</li></ul><p>internet（互联网）是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。</p><p>Internet（互联网，或者因特网）则是一个专用名词，它指当前全球最大的、开放的、众多的网络相互连接而成的特定互连网，它采用 TCP&#x2F;IP 协议族作为通信的规则，且前身是美国的ARPANET。</p><ul><li>第二阶段特点是建成了三级结构的互联网。<strong>主干网</strong>、<strong>地区网</strong>、 <strong>校园网</strong>。</li><li>第三阶段是逐渐形成了<strong>全球范围的多层次ISP结构的互联网</strong>。</li></ul><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><ul><li><strong>边缘部分</strong> 由所有连接在互联网上的主机组成。这部分是用户直接使用的，来进行通信（传送数据、音频或者视频）和资源共享。</li><li><strong>核心部分</strong> 由大量网络和连接这些网络的路由器组成。这部分是<strong>为边缘部分提供服务的</strong>（提供连通性和交换）。</li></ul><img src="https://cdn.jsdelivr.net/gh/kyclnx/image/qq_pic_merged_1708239070178.jpg" style="zoom:50%;" /><h3 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 互联网的边缘部分</h3><p>处在互联网边缘的部分就是连接在互联网上的所有主机。这些主机又称为<strong>端系统</strong>，端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某一个ISP，边缘部分利用核心部分所提供的服务，使得众多主机之间可以相互通信并交换或者共享信息。</p><p>我们先要明确下面的概念。我们说:“主机A和主机B进行通信”，实际上是指:“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指:“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类:客户服务器方式(C&#x2F;S 方式)和对等方式(P2P方式)。下面分别对这两种方式进行介绍。</p><h4 id="1-客户-服务器方式"><a href="#1-客户-服务器方式" class="headerlink" title="1.客户-服务器方式"></a>1.客户-服务器方式</h4><p>这种方式在互联网上是最常用的，也是传统的方式。我们在上网发送电子邮件或在网站上查找资料时，都使用客户-服务器方式(有时写为客户&#x2F;服务器方式)。</p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。在图1-5中，主机A运行客户程序而主机B运行服务器程序。在这种情况下，A是客户而B是服务器。客户A向服务器B发出请求服务，而服务器B向客户A提供服务。这里最主要的特征就是:</p><p><strong>客户是服务请求方，服务器是服务提供方。</strong></p><p>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><img src="https://s2.loli.net/2024/03/03/LdslguOroDzAVy5.png" style="zoom:80%;" /><p>在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点。</p><p><strong>客户程序</strong>:</p><p>(1)被用户调用后运行，在通信时主动向远地服务器发起通信(请求服务)。因此，客户程序必须知道服务器程序的地址。</p><p>(2)不需要特殊的硬件和很复杂的操作系统。</p><p><strong>服务器程序</strong>:</p><p>(1)是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</p><p>(2)系统启动后即一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</p><p>(3)一般需要有强大的硬件和高级的操作系统支持。</p><p>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收</p><h4 id="2-对等连接方式"><a href="#2-对等连接方式" class="headerlink" title="2. 对等连接方式"></a>2. 对等连接方式</h4><p>对等连接方式是指两台主机在互相通信时候，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件他们就可以进行平等的对等连接通信。</p><h3 id="1-3-2-网络的核心部分"><a href="#1-3-2-网络的核心部分" class="headerlink" title="1.3.2 网络的核心部分"></a>1.3.2 网络的核心部分</h3><p>网络的核心部分是互联网中最复杂的成分，因为网络的核心部分要向网络的边缘部分中大量的主机提供连通性，使得边缘部分的任何一台主机都能与其他的主机进行通信。</p><p>网络的核心部分起着特殊作用的是路由器。路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。为了弄清分组交换，下面先介绍电路交换的基本概念。</p><h4 id="1-电路交换的主要特点"><a href="#1-电路交换的主要特点" class="headerlink" title="1. 电路交换的主要特点"></a>1. 电路交换的主要特点</h4><p>当电话机的数量增多时，就要使用很多彼此连接起来的交换机来完成全网的交换任务。用这样的方法，就构成了覆盖全世界的电信网。</p><p>从通信资源的分配角度来看，交换(switching)就是 按照某种方式动态地分配传输线路的资源。在使用电路交换打电话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的物理通路(即把刚才占用的所有通信资源归还给电信网)。这种必须经过“建立连接(占用通信资源)—&gt;通话(一直占用通信资源)—&gt;释放连接(归还通信资源)”三个步骤的交换方式称为电路交换。如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后 再重新拨号。</p><p>电路交换的一个重要特点就是<strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</p><p>当使用电路交换来传送计算机数据的时候，其<strong>线路的传输效率很低</strong>，这是因为计算机数据是突发式的出现在传输线路上的，因此路线上真正用来传送数据的时间往往不到10%甚至1%已被占用的通信资源在绝大部分时间都是空闲的。例如，当用户阅读冬端屏幕上的信息或用键盘输入和编统一份文件时，或计算机正在进行处理而结果尚未返回宝贵的通信线路资源并未被利用而是被白白浪费了。</p><h4 id="2-分组交换的特点"><a href="#2-分组交换的特点" class="headerlink" title="2. 分组交换的特点"></a>2. 分组交换的特点</h4><p>分组交换则采用<strong>存储转发</strong>的技术。图1-9 表示把一个报文划分为几个分组以后再进行传输。通常把要发送的整块数据称为一个<strong>报文</strong>先把较长的报文划分为一个个更小的等长数据段，例如，每个数据段为1024 bit。 在每一个数据段前面，加上一些必要的控制信息组成的首部(header)后，就构成了一个分组(packet)。分组又称为<strong>“包”</strong>，而分组的首部也可称为<strong>“包头”</strong>。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240303120516.png" style="zoom:50%;" /><p>互联网的核心部分是由许多网络和把它们互连起来的路由器组成的，而主机处在互联网的边缘部分。在互联网核心部分的路由器之间一般都用高速链路相连接，而在网络边缘部分的主机接入到核心部分则通常以相对较低速率的链路相连接。</p><p>位于网络边缘部分的主机和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器则用来转发分组，即进行分组交换。路由器收到一个分组，先暂时存储一下， 检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步步地(有时会经过几十个不同的路 由器)以存储转发的方式，把分组交付最终的目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表在整个网络拓扑发生变化时及时更新。</p><p>分组交换在传送数据之前不必先占用一条端到端的通信资源，分组在哪段链路上传送才占用那条链路的通信资源。分组到达路由器之后，先暂时存储下来，查找转发表，然后从另一条合适的链路转发出去。<strong>分组在传输时候就这样逐段地断续占用通信资源</strong>，省去了建立连接和释放连接的开销，因而数据的传输效率更高。</p><p>互联网采取了专门的措施，保证了数据的传送有着非常高的可靠性。当网络中的某些节点或链路突然出现故障时候，在各路由器中运行的路由选择协议能够自动找到转发分组的最合适的路径。</p><p><strong>电路交换</strong>—整 个报文的比特流连续地从源点直达终点，好像在一个管道中传递。</p><p><strong>报文交换</strong>—整个报文先传送到相邻节点， 全部存储下来后查找转发表，转发到下一个节点。</p><p><strong>分组交换</strong>—单个分组 (这只是整个报文的一部分) 传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</p><img src="https://s2.loli.net/2024/03/03/qjbprhF6XxwPiGz.png" style="zoom:67%;" /><h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="1-6-1-计算机网络的性能指标"><a href="#1-6-1-计算机网络的性能指标" class="headerlink" title="1.6.1 计算机网络的性能指标"></a>1.6.1 计算机网络的性能指标</h3><ol><li><strong>速率</strong>：网络技术中的速率指的是数据传送速率速率的单位是bit&#x2F;s</li><li><strong>带宽</strong>:  在计算机网络中表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中某信道所能通过的<strong>“最高数据率”</strong>，这种意义的<strong>带宽的单位</strong>就是<strong>数据率的单位bit&#x2F;s，“是比特每秒”。</strong></li><li><strong>吞吐量</strong></li><li><strong>时延</strong>：发送时延、传播时延、处理时延、排队时延</li><li><strong>时延带宽积</strong></li><li><strong>往返时间RTT</strong></li><li><strong>利用率</strong></li></ol><h2 id="1-7-计算机网络的体系结构"><a href="#1-7-计算机网络的体系结构" class="headerlink" title="1.7 计算机网络的体系结构"></a>1.7 计算机网络的体系结构</h2><h3 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h3><p>网络协议三要素：</p><p>(1) 语法，即数据与控制信息的结构或格式;</p><p>(2)语义，即需要发出何种控制信息，完成何种动作以及做出何种响应;</p><p>(3)同步，即事件实现顺序的详细说明。</p><h3 id="1-7-3具有五层协议的体系结构"><a href="#1-7-3具有五层协议的体系结构" class="headerlink" title="1.7.3具有五层协议的体系结构"></a>1.7.3具有五层协议的体系结构</h3><p>OSI的七层协议体系结构(如图1-16(a)所示)的概念清楚，理论也较完整，但它既复杂又不实用。TCP&#x2F;P 体系结构则不同，它现在得到了非常广泛的应用。TCP&#x2F;P 是一个四层的体系结构(如图所示)， 它包含应用层、运输层、网际层和链路层(网络接口层)。用网际层这个名字是强调本层解决不同网络的互连问题。在互联网的标准文档[RFC 1122, STD3]中，体系结构中的底层叫作链路层，但接着又说明了链路层就是媒体接入层。但也有把链路层称为网络接口层的[COME06]或子网层的[PETE12]。从实质上讲，TCP&#x2F;IP 只有最上面的三层，因为最下面的链路层并没有属于TCP&#x2F;IP体系的具体协议。链路层所使用的各种局域网标准，并非由IETF而是由IEEE的802委员会下属的各工作组负贵制定的。在讲授计算机网络原理时往往采取另外的办法，即综合OSI和TCPIP的优点，采用如图1-16(c)所示的五层协议的体系结构，这对阐述计算机网络的原理是十分方便的。</p><p><img src="https://s2.loli.net/2024/03/03/RgD7a1SFduPrikz.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组篇三</title>
    <link href="/2024/01/31/arr3/"/>
    <url>/2024/01/31/arr3/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><a href="https://leetcode.cn/problems/spiral-matrix/description/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><p>递归的一种写法不会让人一下子就能想得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        circle(matrix, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//遍历以x1,y1为左上角;x2,y2为右下角的一圈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">circle</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2,List&lt;Integer&gt; ans)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x1 &gt; x2 || y1 &gt; y2) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//只有一行的情况下</span><br>        <span class="hljs-keyword">if</span>(x1 == x2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> y1; i &lt;= y2; i++) ans.add(mat[x1][i]); <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//只有一列的情况下</span><br>        <span class="hljs-keyword">if</span>(y1 == y2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x1; i &lt;= x2; i++) ans.add(mat[i][y1]);<span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> y1; i &lt; y2; i++) ans.add(mat[x1][i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x1; i &lt; x2; i++) ans.add(mat[i][y2]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> y2; i &gt; y1; i--) ans.add(mat[x2][i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x2; i &gt; x1; i--) ans.add(mat[i][y1]);<br>        circle(mat,x1 + <span class="hljs-number">1</span>, y1 + <span class="hljs-number">1</span>, x2 - <span class="hljs-number">1</span>, y2 - <span class="hljs-number">1</span>, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = matrix.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Integer[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(r + <span class="hljs-number">1</span>)*(b + <span class="hljs-number">1</span>)];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++) res[x++] = matrix[t][i];<span class="hljs-comment">//从左向右（变列数）</span><br>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b; i++) res[x++] = matrix[i][r];<span class="hljs-comment">//从上往下（变行数）</span><br>            <span class="hljs-keyword">if</span> (l &gt; --r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l; i--) res[x++] = matrix[b][i];<span class="hljs-comment">//从右向左</span><br>            <span class="hljs-keyword">if</span> (t &gt; --b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t; i--) res[x++] = matrix[i][l];<span class="hljs-comment">//从下向上</span><br>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.asList(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, end = n*n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = n - <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start &lt;= end)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++) ans[t][i] = start++;<br>            t++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b; i++) ans[i][r] = start++;<br>            r--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l; i--) ans[b][i] = start++;<br>            b--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t; i--) ans[i][l] = start++;<br>            l++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++)&#123;<br>            List&lt;Integer&gt; r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || j == i)&#123;<br>                    r.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r.add(ans.get(i - <span class="hljs-number">1</span>).get(j - <span class="hljs-number">1</span>) + ans.get(i - <span class="hljs-number">1</span>).get(j));<br>                &#125;<br>            &#125;<br>            ans.add(r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">119. 杨辉三角 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row_Index)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= row_Index; i++)&#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || j == i)&#123;<br>                    tmp.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    tmp.add(ans.get(i - <span class="hljs-number">1</span>).get(j - <span class="hljs-number">1</span>) + ans.get(i - <span class="hljs-number">1</span>).get(j));<br>                &#125;<br>            &#125;<br>            ans.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.get(row_Index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组篇二</title>
    <link href="/2024/01/30/arr2/"/>
    <url>/2024/01/30/arr2/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//L[i]代表了nums[i]左侧的乘积</span><br>        <span class="hljs-type">int</span>[] L = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">//R[i]代表了nums[i]右侧的乘积</span><br>        <span class="hljs-type">int</span>[] R = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        R[n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) R[i] = nums[i + <span class="hljs-number">1</span>]*R[i + <span class="hljs-number">1</span>];<br>        L[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) L[i] = nums[i - <span class="hljs-number">1</span>]*L[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) ans[i] = L[i]*R[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/h-index/description/">274. H 指数 - 力扣（LeetCode）</a></p><p>此次题目有一些模糊，其题意大概是，在数组中寻找一个数字h（尽可能大），h表示数组中至少有h个数字都大于等于h</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, compare = <span class="hljs-number">0</span>;<br>        Arrays.sort(citations);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            compare = Math.min(n - i, citations[i]);<br>            ans = Math.max(ans, compare);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/submissions/505342795/">453. 最小操作次数使数组元素相等 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            ans += nums[i] - t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-decreasing-array/">665. 非递减数列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPossibility</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt;= nums[j]) f[i] = Math.max(f[i], f[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            ans = Math.max(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  ans &gt;= n - <span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/move-zeroes/description/">283. 移动零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; n)&#123;<br>            <span class="hljs-keyword">if</span> (nums[r] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[r];<br>                nums[r] = nums[l];<br>                nums[l] = tmp;<br>                l++;<br>            &#125;<br>            r++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reshape-the-matrix/submissions/499328906/">566. 重塑矩阵 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixReshape(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(r*c != m*n) <span class="hljs-keyword">return</span> mat;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r][c];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(col == c)&#123;<br>                    col = <span class="hljs-number">0</span>;<br>                    row++;<br>                &#125;<br>                ans[row][col] = mat[i][j];<br>                col++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/diagonal-traverse/description/">498. 对角线遍历 - 力扣（LeetCode）</a></p><p>因为沿着对角线遍历只会面临两种情况，向着右上角遍历或者向着左下角进行遍历，所以创建一个direct ，当它&#x3D;1的时候，它沿着右上角方向进行遍历，，当它等于-1的时候它沿着左下角方向进行遍历。<em><strong>此题目对于越界情况的处理及其巧妙</strong></em></p><blockquote><ul><li>右上方越界情况处理：只考虑列数情况</li><li>左下方越界情况处理： 只考虑行数情况</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findDiagonalOrder(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length, n = mat[<span class="hljs-number">0</span>].length, cnt = m*n;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cnt];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, direct = <span class="hljs-number">1</span>, flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag &lt; cnt)&#123;<br>            ans[flag] = mat[x][y];<br>            flag++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ny = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//direct = 1沿着右上角的方向进行遍历</span><br>            <span class="hljs-keyword">if</span>(direct == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//行数减一</span><br>                nx = x - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//列数加一</span><br>                ny = y + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(direct == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//行数加一</span><br>                nx = x + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//列数减一</span><br>                ny = y - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//处理越界的情况</span><br>            <span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &lt; <span class="hljs-number">0</span> || ny &gt;= n)&#123;<br>                <span class="hljs-comment">//右上方的越界情况处理</span><br>                <span class="hljs-keyword">if</span>(direct == <span class="hljs-number">1</span>)&#123;<br>                    nx = y + <span class="hljs-number">1</span> &lt; n ? x : x + <span class="hljs-number">1</span>;<br>                    ny = y + <span class="hljs-number">1</span> &lt; n ? y + <span class="hljs-number">1</span> : y;<br>                &#125;<br>                <span class="hljs-comment">//左下方的越界情况处理</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    nx = x + <span class="hljs-number">1</span> &lt; m ? x + <span class="hljs-number">1</span> : x;<br>                    ny = x + <span class="hljs-number">1</span> &lt; m ? y : y + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//越界变方向</span><br>                direct *=  -<span class="hljs-number">1</span>;<br>            &#125;<br>            x = nx;<br>            y = ny;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组篇一</title>
    <link href="/2024/01/29/arr1/"/>
    <url>/2024/01/29/arr1/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><a href="https://leetcode.cn/problems/rotate-image/description/">48. 旋转图像 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                tmp[j][m - i - <span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                matrix[i][j] = tmp[i][j];<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/submissions/499219575/">73. 矩阵置零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m];<br>        <span class="hljs-type">boolean</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    row[i] = <span class="hljs-literal">true</span>;<br>                    col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(col[j] == <span class="hljs-literal">true</span> || row[i] == <span class="hljs-literal">true</span>) matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/game-of-life/description/">289. 生命游戏 - 力扣（LeetCode）</a></p><ul><li>使用<code>.clone</code>只是对于数组进行了浅拷贝，意思就是，修改到原数组仍然会影响到复制后的数组</li></ul><p>对于此题目，我本来想着使用<code>.clone</code>方法直接拷贝一份原数组，然后进行之后的操作发现我修改了复制之后的数组原数组也会跟着改变，这也算是学到了一些吧~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gameOfLife</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] cp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span>[] neighbours = &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            System.arraycopy(board[i], <span class="hljs-number">0</span>, cp[i], <span class="hljs-number">0</span>, n);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-comment">//统计每个细胞周围的活细胞</span><br>                <span class="hljs-comment">//因为每次统计之后会修改原数组，所以需要复制一份原数组</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">live_body</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">3</span>; l++)&#123;<br>                        <span class="hljs-comment">//防止统计到自己</span><br>                        <span class="hljs-keyword">if</span>(!(neighbours[k] == <span class="hljs-number">0</span> &amp;&amp; neighbours[l] == <span class="hljs-number">0</span>))&#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + neighbours[k];<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> j + neighbours[l];<br>                            <span class="hljs-keyword">if</span> ((r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; m) &amp;&amp; (c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &amp;&amp; cp[r][c] == <span class="hljs-number">1</span>)&#123;<br>                                live_body ++;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cp[i][j] == <span class="hljs-number">1</span> &amp;&amp; (live_body &lt; <span class="hljs-number">2</span> || live_body &gt; <span class="hljs-number">3</span>)) board[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(cp[i][j] == <span class="hljs-number">0</span> &amp;&amp; (live_body == <span class="hljs-number">3</span>)) board[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/image-smoother/description/">661. 图片平滑器 - 力扣（LeetCode）</a></p><p>求周围平均值的模板模拟题类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] imageSmoother(<span class="hljs-type">int</span>[][] img) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> img.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> img[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span>[] neighbours = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <br>                <span class="hljs-type">int</span> <span class="hljs-variable">avg</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//统计每次的平均值</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">numbers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">3</span>; l++) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + neighbours[k];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> j + neighbours[l];<br>                        <span class="hljs-keyword">if</span>((r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; m) &amp;&amp; (c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n))&#123;<br>                            avg += img[r][c];<br>                            numbers++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                ans[i][j] = avg/numbers;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] imageSmoother(<span class="hljs-type">int</span>[][] img) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> img.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> img[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n - <span class="hljs-number">1</span>; j++)&#123;<br>                ans[i][j] = count(i, j, img);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>[][] img)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> img.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> img[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, number = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; j&lt;= <span class="hljs-number">1</span>; j++)&#123;<br>                x = a + i;<br>                y = b + j;<br>                <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n)&#123;<br>                    sum += img[x][y];<br>                    number++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum/number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/range-addition-ii/submissions/505170060/">598. 区间加法 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] ops)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] op : ops)&#123;<br>            m = Math.min(m, op[<span class="hljs-number">0</span>]);<br>            n = Math.min(n, op[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> m*n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/battleships-in-a-board/submissions/505173120/">419. 甲板上的战舰 - 力扣（LeetCode）</a></p><p>横着或者竖着相连的 ‘X’ 的【一组】代表同一艘战舰。</p><blockquote><p>水平战舰：如果一行中有连续的 ‘X’，它们构成了一艘战舰。</p></blockquote><blockquote><p>垂直战舰：如果一列中有连续的 ‘X’，它们也构成了一艘战舰。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBattleships</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;X&#x27;</span>) ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/rotate-array/description/">189. 轮转数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) newArr[(i + k) % n] = nums[i];<br>        System.arraycopy(newArr, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/rotate-function/description/">396. 旋转函数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRotateFunction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>*n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>*n; i++) sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[(i - <span class="hljs-number">1</span>)%n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) ans += i*nums[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>*n; i++)&#123;<br>            tmp += nums[(i - <span class="hljs-number">1</span>) % n]*(n - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//这里其实就是减去了一个前缀和</span><br>            tmp = tmp - (sum[i - <span class="hljs-number">1</span>] - sum[i - n]);<br>            ans = Math.max(ans, tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇测试文章</title>
    <link href="/2024/01/28/hello-world/"/>
    <url>/2024/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
